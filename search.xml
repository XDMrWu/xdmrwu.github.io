<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0-1背包问题</title>
    <url>/2016/04/17/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.问题描述</p>
<p>有n个物品，第i个物品的体积和价值分别为w[i]、v[i](1&lt;&#x3D; i &lt;&#x3D;n)，现有一个容量为c的背包，将这些物品选择装入该背包，如何选择使得包里的物品价值总和最大。</p>
<p>2.问题分析</p>
<p>定义函数f[i][w]表示从前i件物品中选择放入容量为w的背包能装下的物品最大价值，我们所要求的就是f[n][c]。以n为例，有两种情况:</p>
<p>a. 如果w[n]&gt;c，那么n就不能选中，即f[n][c] &#x3D; f[n-1][c]</p>
<p>b. 如果w[n] &lt;&#x3D; c, 那么n有可能选中也可能没有选中，依据就是判断选中和不选中的结果哪个大酒根据那一个，即比较f[n-1][c-w[n]]+v[n]和f[n-1][c]</p>
<p>3.编写代码</p>
<p>在解决该问题时因为每一个f都依赖上一个结果，所以需要从最小的f开始向上计算，得到结果，易得f[0][i] f[i][0]都是0，我们需要从0开始计算出所有f[][]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i表示从前i项选择，j表示容量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (w[i] &gt; j) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> c, <span class="type">int</span> v[], <span class="type">int</span> w[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][c];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, v[<span class="number">1001</span>];</span><br><span class="line">    <span class="type">int</span> c, w[<span class="number">1001</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">knapsack</span>(n, c, v, w) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想得到选择的具体情况可以通过f[i][c]-f[i-1][c]的值判断,如果f[i][c]&gt;f[i-1][c],那么就是选取了第i个，接下来就要判断f[i - 1][c - w[i]] 和f[i - 2][c - w[i]]，注意i从大到小判断，遇到被选中的，加下来的判断就要减去这个重量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w = totalWeight;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i != <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[i][w] &gt; f[i - <span class="number">1</span>][w]) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	    w -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Android事件分发机制详解</title>
    <url>/2016/07/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前在学习android事件方法机制的时候，看过不少文章，但是大部分都讲的不是很清楚，我自己理解的也是云里雾里，也尝试过阅读源码，看得我更是不知所措。最近阅读了《Android开发艺术探索》一书中相关的章节，茅塞顿开，写下本文作为阅读笔记，以便以后查阅。</p>
<h1 id="三个重要的方法"><a href="#三个重要的方法" class="headerlink" title="三个重要的方法"></a>三个重要的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span><br></pre></td></tr></table></figure>
<p>事件传递过来的时候这个方法第一个被调用，返回结果受当前View的ontouchEvent()方法或者下一级View的dispatchTouchEvent()方法返回值影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span><br></pre></td></tr></table></figure>
<p>这个方法是在dispatchTouchEvent()方法内部掉用的，返回值用来判断是否拦截当前事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent ev)</span></span><br></pre></td></tr></table></figure>
<p>也是在dispatchTouchEvent()方法中掉用，用来处理某一事件。</p>
<h1 id="事件的传递规则"><a href="#事件的传递规则" class="headerlink" title="事件的传递规则"></a>事件的传递规则</h1><p>书中用了一段伪代码来表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说当一个事件到来的时候，当前View的dispatchTouchEvent方法会被调用，在内部首先调用onInterceptTouchEvent判断是否拦截，如果拦截，将事件传递给自己的onTouchEvent对事件进行处理。如果不拦截，就将事件传递给子View，调用子View的dispatchTouchEvent方法，一直到事件被消费。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>上面的内容讲的很抽象，不好理解，接下来配合源码来讲解，这样更加的容易深入理解事件分发机制。</p>
<h3 id="判断是否拦截"><a href="#判断是否拦截" class="headerlink" title="判断是否拦截"></a>判断是否拦截</h3><p>事件到来的时候，View的第一个工作自然是判断是否拦截，下面给出dispatchTouchEvent中拦截的相关代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，事件分发机制针对的其实可以看作是一系列的事件，也就是一个事件序列，也就是说一个事件序列由一个DOWN开头，中间n个MOVE，然后以UP或者CANCEL结束。</p>
<p>代码中mFirstTouchTarget在子元素成功处理事件的时候会进行赋值，也就是说当事件不是DOWN，而且没有子元素成功处理的时候，直接拦截事件自己处理。这很好理解，如果不是DOWN说明事件序列已经开始传递了，那么如果子元素不处理最开始的DOWN说明它不想要这个序列，那么就自己处理，一直到新的事件序列到来（也就是新的DOWN）。也就是说一旦我们处理一个事件就不会多次调用onInterceptTouchEvent方法。</p>
<p>另一种情况是DOWN到来，也就是新的事件序列开始，或者子View成功处理过这个序列，就会进行判断。判断第一步是判断FLAG_DISALLOW_INTERCEPT标志位，这个标志位是通过requestDisallowInterceptTouchEvent方法设置的，一般是子View调用的，如果不允许拦截，就不拦截。如果允许，那就调用自己的onInterceptTouchEvent方法来判断。</p>
<p>值得注意的是当DOWN事件到来的时候，会重置标志位，且清除mFirstTouchTarget，就是新序列到来的时候一切重置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle an initial down.</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不拦截事件"><a href="#不拦截事件" class="headerlink" title="不拦截事件"></a>不拦截事件</h3><p>如果最后不拦截事件，那么就应该分发下去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> customOrder</span><br><span class="line">                                    ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> (preorderedList == <span class="literal">null</span>)</span><br><span class="line">                                    ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                            <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                            <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                            <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                                <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                                <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                            <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>就是遍历子View，通过是否在播放动画和事件是否落在它的范围内来获得合适的View，如果存在就调用它的dispatchTouchEvent方法。<br>我们需要获得dispatchTouchEvent返回的值来判断子View是否成功消耗了事件，如果返回的是true代表成功消费，那么就会对mFirstTouchTarget进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这个赋值很重要，如果不消耗那么就不会赋值，也就是说mFirstTouchTarget&#x3D;&#x3D; null，那么接下来的事件（同一序列，也就不会再产生DOWN了）都有本View消耗，不再分发。</p>
<p>当然，如果最后发现没有合适的子View或者子View返回了false，那么都由本View处理，也就是onTouchEvent，这也就是为什么事件到了最底层还没被消耗（返回true）就会重新向上传递到上一层的onTouchEvent处理的原因了。</p>
<h3 id="拦截事件"><a href="#拦截事件" class="headerlink" title="拦截事件"></a>拦截事件</h3><p>那就开始自己处理事件，接下来的内容就会详细讲解。</p>
<h3 id="View对事件的处理"><a href="#View对事件的处理" class="headerlink" title="View对事件的处理"></a>View对事件的处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line"><span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">        &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">    result = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的View不包含ViewGroup，可以看到当要处理事件的时候首先判断是否设置了OnTouchListener，如果设置了就调用onTouch方法。如果onTouch返回了true，那么就直接返回，不会去调用ontouchEvent。如果返回了false，就回调用ontouchEvent，返回onTouchEvent的返回值。<br>在onTouchEvent内部，如果设置了OnClickListener就会调用onClick方法。<br>总的来说，就是onTouchListener级别高于onTouchEvent，onClickListener最低。</p>
<h1 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h1><p>针对上述的理论分析，我们通过以下的Demo来结合实践加深理解。<br>首先自定义一个MyViewGroup和MyView，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyViewGroup</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyView mChildView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewGroup</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            mChildView = (MyView) getChildAt(<span class="number">0</span>);</span><br><span class="line">            mChildView.layout(l, t, l + mChildView.getMeasuredWidth(), t + mChildView.getMeasuredHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很简单的自定义View和ViewGroup，我们接下来在布局文件中加入就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span> android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span> android:paddingLeft=<span class="string">&quot;@dimen/activity_horizontal_margin&quot;</span></span><br><span class="line">    android:paddingRight=<span class="string">&quot;@dimen/activity_horizontal_margin&quot;</span></span><br><span class="line">    android:paddingTop=<span class="string">&quot;@dimen/activity_vertical_margin&quot;</span></span><br><span class="line">    android:paddingBottom=<span class="string">&quot;@dimen/activity_vertical_margin&quot;</span> tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.wulingpeng.viewtouchdispatch.MyViewGroup</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> &gt;</span><br><span class="line">        </span><br><span class="line">        &lt;com.wulingpeng.viewtouchdispatch.MyView</span><br><span class="line">            android:layout_width=<span class="string">&quot;300dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;300dp&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;@android:color/holo_blue_bright&quot;</span>/&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/com.wulingpeng.viewtouchdispatch.MyViewGroup&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们重写MyViewGroup和View的相关方法并打印结果</p>
<p>MyView.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dispatch</span> <span class="operator">=</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;MyView:dispatchTouchEvent &quot;</span> + dispatch);</span><br><span class="line">    <span class="keyword">return</span> dispatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">onTouchEvent</span> <span class="operator">=</span> <span class="built_in">super</span>.onTouchEvent(event);</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;MyView:OnTouchEvent &quot;</span> + onTouchEvent);</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyViewGroup.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dispatch</span> <span class="operator">=</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;MyViewGroup:dispatchTouchEvent &quot;</span> + dispatch);</span><br><span class="line">    <span class="keyword">return</span> dispatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isIntercept</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            isIntercept = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;MyViewGroup:onInterceptTouchEvent &quot;</span> + isIntercept);</span><br><span class="line">    <span class="keyword">return</span> isIntercept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">onTouchEvent</span> <span class="operator">=</span> <span class="built_in">super</span>.onTouchEvent(event);</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;MyViewGroup:OnTouchEvent &quot;</span> + onTouchEvent);</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们拦截了DOWN事件，接下来点击MyView的区域然后滑动，最后抬起。</p>
<p><img src="/images/viewtouch.gif" alt="这里写图片描述"><br>打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">07-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:onInterceptTouchEvent true</span><br><span class="line">07-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:OnTouchEvent false</span><br><span class="line">07-23 08:57:18.067 2831-2831/? D/Debug: MyViewGroup:dispatchTouchEvent false</span><br></pre></td></tr></table></figure>
<p>明明滑动了一段距离，理论上有很多个MOVE事件，为什么只有三个打印呢？其实之前就已经说明了，我们拦截了DOWN事件，那么子元素是收不到DOWN事件的，结果就是该序列接下来的事件都是我们自己消费，且不会再次掉用onInterceptTouchEvent，由自己的onTouchEvent处理。因为我们的onTouchEvent返回了false，直接导致我们的dispatchTouchEvent也返回了false。那么MyViewGroup的上一层就不会把接下来的事件传递给我们了（上一层的mFirstTouchTarget没有赋值），所以接下来的事件都不会到来。</p>
<p>我们再改变一下，让MyViewGroup的onTouchEvent方法返回true，进行相同的操作，打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">07-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:onInterceptTouchEvent true</span><br><span class="line">07-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:OnTouchEvent true</span><br><span class="line">07-23 09:08:48.727 3018-3018/? D/Debug: MyViewGroup:dispatchTouchEvent true</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>省略的打印信息就是第二条和第三条的多次重复，也就是说在接下来的MOVE到来的时候，由于之前拦截了DOWN，所以事件自己处理，不会再掉用onIntereptTouchEvent。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>一般在处理滑动冲突的时候重写相关方法，对于DOWN事件是不会拦截的，也就是返回false，在接下来的MOVE序列中判断是否需要拦截。因为如果拦截了DOWN，那么接下来的事件都不会传给子View了，之前已经分析过了。</li>
<li>一般也不会拦截UP事件，因为UP一般为序列的最后一个事件，拦截不拦截对自己没有什么用处，但是子View就可能因为收不到UP而无法触发click事件。</li>
</ul>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Android内存泄漏简介</title>
    <url>/2019/10/09/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="内存泄漏概念"><a href="#内存泄漏概念" class="headerlink" title="内存泄漏概念"></a>内存泄漏概念</h1><p>内存泄漏指的是一个本该被回收的对象因为某些原因导致其不能被回收，通俗来说就是该对象理论上不再使用，但是仍无法被回收。</p>
<h1 id="Android中的泄漏对象"><a href="#Android中的泄漏对象" class="headerlink" title="Android中的泄漏对象"></a>Android中的泄漏对象</h1><p>判断一个对象是否泄漏首先要判断该对象是否不再使用，想要判断这一点则需要对象有明显的生命周期，在Android中有以下对象可以判断是否泄漏:</p>
<ul>
<li>Activity: 通过Activity的mDestroyed属性来判断该Activity是否已经销毁，如果已经销毁且未被回收则认为是泄漏</li>
<li>Fragment: 通过Fragment的mFragmentManager是否为空来判断该Fragment是否处于无用状态，如果mFragmentManager为空且未被回收则认为是泄漏。</li>
<li>View: 通过unwrapper mContext获得Activity，如果存在Activity，则判断该Activity是否泄漏。</li>
<li>Editor: Editor指的是android.widget包下的Editor，是用于TextView处理editable text的辅助类，通过mTextView是否为空来判断Editor是否处于无用状态，如果mTextView为空且未被回收则认为是泄漏。</li>
<li>ContextWrapper: 通过unwrapper ContextWrapper获得Activity，如果存在Activity，则判断该Activity是否泄漏。</li>
<li>Dialog: 通过mDecor是否为空判断该Dialog是否处于无用状态，如果mDecor为空且未被回收则认为是泄漏。</li>
<li>MessageQueue: 通过mQuitting或者mQuiting(应该是历史原因，前期拼写错误为mQuiting，后来改正)来判断MessageQueue是否已经退出，如果已经退出且未被回收则认为是泄漏。</li>
<li>ViewRootImpl: 通过ViewRootImpl的mView是否为空来判断该ViewRootImpl是否处于无用状态，如果mView为空且未被回收则认为是泄漏。</li>
<li>Window: 通过mDestroyed来判断该Window是否处于无用状态，如果mDestroyed为true且未被回收则认为是泄漏。</li>
<li>Toast: 拿到mTN，通过mTN的mView是否为空来判断当前Toast是否已经hide，如果已经hide且未被回收则认为是泄漏。</li>
</ul>
<h1 id="泄漏的形式"><a href="#泄漏的形式" class="headerlink" title="泄漏的形式"></a>泄漏的形式</h1><p>泄漏的本质就是无用对象被持有导致无法回收，具体的形式有如下几种：</p>
<ul>
<li>非静态内部类、匿名内部类持有外部类对象引用: 一般为用于回调的Listener，该Listener被别的地方持有，间接导致外部类对象被泄漏。</li>
<li>Handler: 在Activity中定义Handler对象的时候，Handler持有Activity同时Message持有Handler，而Message被MessageQueue持有，最终导致Activity泄漏。</li>
<li>资源对象未关闭: 数据库连接、Cursor、IO流等使用完后未close。</li>
<li>属性动画: 使用ValueAnimator和ObjectAnimator的时候，未及时关闭动画导致泄漏。Animator内部向AnimationHandler注册listener，AnimationHandler是一个单例，如果不及时cancel，会导致Animator泄漏，间接导致Activity&#x2F;Fragment&#x2F;View泄漏（比如Animator的updateListener一般都以匿名内部类实现）</li>
<li>逻辑问题: 注册监听器之后未及时解注册，比如使用EventBus的时候没有在合适的时候进行解注册</li>
</ul>
]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>Button点击时滑动的事件传递</title>
    <url>/2017/11/02/Button%E7%82%B9%E5%87%BB%E6%97%B6%E6%BB%91%E5%8A%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前面试的时候遇到一个有关滑动事件的问题，让我十分费解，后来查阅相关资料和源码才得以解决，问的是在一个RecyclerView中，有一个item为Button，如果在按下这个Button的同时进行滑动，Button是否能够保持焦点？相关事件是如何传递的？</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>按照以往我对事件传递机制的理解，在按下的时候是一个Down事件ViewGroup-&gt;Button，然后滑动的时候就是一系列Move事件，但是由于向上的Move事件会被ViewGroup(RecyclerView)拦截，所以Button就会失去焦点，实验结果也是如此，但是如果ViewGroup真的拦截了Move之后的所有事件，Button是如何得知自己失去焦点并更新UI为失去焦点的UI(至少得获得一个CANCEL或者UP事件吧?)。实验证明却是在Move被拦截后接收到了CANCEL事件，但是这个CANCEL是如何来的呢？</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>在ViewGroup的dispatchTouchEvent方法的最后一部分有这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">next</span> <span class="operator">=</span> target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">cancelChild</span> <span class="operator">=</span> resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="literal">null</span>) &#123;</span><br><span class="line">                mFirstTouchTarget = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程是先判断事件是否已经传递给child处理，如果是就返回，如果没有那么就会尝试通过dispatchTransformedTouchEvent给child传递一个CANCEL事件，部分代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出就是这里给child传递了CANCEL事件</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Android共享元素动画原理解析</title>
    <url>/2019/04/16/Android%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Andriod 5.0及之后开始支持Activity之间的共享元素动画，共享元素即启动Activity的时候，Activity A中的控件能够通过动画的方式流畅的过渡到Activity B中对应的控件。<br>之前在项目中用到了共享元素动画，遇到了一些坑，碍于不了解底层原理&amp;时间紧迫，实现的效果并不完美。最近得空带着一些疑惑阅读了一波源码，本文将带着这些问题来一步步解析源码，下图为实现效果。</p>
<!-- <center><img src="/images/shared1.gif" width="200px" /></center> -->
<p><img src="/images/shared1.gif"><br>PS:本文源码基于android-28</p>
<h2 id="使用共享元素动画"><a href="#使用共享元素动画" class="headerlink" title="使用共享元素动画"></a>使用共享元素动画</h2><p>使用共享元素动画很简单，只需要三步</p>
<ol>
<li>通过给两个Activity设定<code>Window.FEATURE_CONTENT_TRANSITIONS</code>来启用transition api</li>
<li>给两个Activity对应的控件加上transitionName属性，且对应控件的transitionName应该保持一致</li>
<li>使用<code>public void startActivity(Intent intent, @Nullable Bundle options)</code>方法启动Activity</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startActivity(Intent(<span class="built_in">this</span>, TargetActivity::class.java), createTransitionBundle())</span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">createTransitionBundle</span><span class="params">()</span>: Bundle? &#123;</span><br><span class="line">    <span class="keyword">return</span> ActivityOptionsCompat.makeSceneTransitionAnimation(<span class="built_in">this</span>, Pair(avatar, <span class="string">&quot;avatar&quot;</span>), Pair(bg, <span class="string">&quot;bg&quot;</span>), Pair(user_name, <span class="string">&quot;user_name&quot;</span>)).toBundle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ActivityOptionsCompat.makeSceneTransitionAnimation</code>方法接受类型为Pair&lt;View,String&gt;的可变长数组，对应参与共享元素动画的View和transitionName，该方法可以支持多个共享元素。</p>
<p>通过以上方式就已经可以简单的实现共享元素动画，但是如果被启动的Activity中对应的View因为某些原因(等待网络请求等)不能立即展示，而是需要等待一段时间才能显示，那么在View没有显示的时候做共享元素动画显然是不合理的，所以Android提供了两个方法让我们可以延迟动画的开始时机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延迟enter动画</span></span><br><span class="line">supportPostponeEnterTransition()</span><br><span class="line"><span class="comment">// 开始执行enter动画</span></span><br><span class="line">supportStartPostponedEnterTransition()</span><br></pre></td></tr></table></figure>
<p>我们可以在被启动的Activity的onCreate方法中调用<code>supportPostponeEnterTransition()</code>来延迟动画的执行，并在我们认为时机到了的时候(View被正常绘制后)调用<code>supportStartPostponedEnterTransition()</code>来开始执行共享元素动画。</p>
<h2 id="共享元素动画大致流程"><a href="#共享元素动画大致流程" class="headerlink" title="共享元素动画大致流程"></a>共享元素动画大致流程</h2><p>本节大致介绍一下从startActivity到动画执行完毕的过程中发生了什么事情，以便对共享元素动画有一个大致的认识，这样更加有利于理解后续的源码解析。<br>首先引入五个类，这五个类承担共享元素动画的大部分逻辑。</p>
<!-- <p class="img-tip" data-str="image.png"><img src='/images/shared2.png' height=250/></p> -->
<p><img src="/images/shared2.png"></p>
<ul>
<li><strong>ResultReceiver</strong>：ResultReceiver是一个用来接收其他进程回调结果的通用接口。要使用它，需要创建一个子类并且实现<code>onReceiveResult(int, android.os.Bundle)</code>方法，在其他线程（进程）中可以通过<code>send(int, android.os.Bundle)</code>方法发送数据，底层实现是对Binder的简单封装</li>
<li><strong>ActivityTransitionCoordinator</strong>：继承自ResultReceiver，是ExitTransitionCoordinator 和 EnterTransitionCoordinator的基类,负责管理Activity的动画和Activity之间的通信</li>
<li><strong>EnterTransitionCoordinator</strong>：继承自ActivityTransitionCoordinator，负责启动Activity时的enter动画</li>
<li><strong>ExitTransitionCoordinator</strong>：继承自ActivityTransitionCoordinator，负责启动Activity时的exit动画</li>
<li><strong>ActivityTransitionState</strong>：与Activity交互，作为Activity与ActivityTransitionCoordinator间的沟通桥梁</li>
</ul>
<p>一次典型的startActivity动画流程如下所示:</p>
<ol>
<li>ExitTransitionCoordinator在<code>ActivityOptions#makeSceneTransitionAnimation</code>方法中被创建，并将它传入options中返回</li>
<li><code>Activity#startActivity</code>最终调用到<code>cancelInputsAndStartExitTransition()</code>触发<code>ExitTransitionCoordinator#startExit()</code>，隐藏其余的View同时将SharedViews移动到顶层</li>
<li>Activity B启动，通过<code>ActivityTransitionState#enterReady</code>来创建EnterTransitionCoordiantor，同时调用它的<code>startEnter()</code>做一些准备操作<ul>
<li><code>MSG_SET_REMOTE_RECEIVER</code>被发送给ExitTransitionCoordinator来设置相互的引用</li>
<li>将Window设置为透明</li>
<li>Window的background设置为alpha&#x3D;0</li>
<li>将不参与SharedTransition的View和SharedViews设置为alpha&#x3D;0</li>
<li>将SharedViews移动到顶层</li>
</ul>
</li>
<li>ExitTransitionCoordinator的exit动画结束后发送<code>MSG_TAKE_SHARED_ELEMENTS</code>给EnterTransitionCoordinator，EnterTransitionCoordinator开始动画<ul>
<li>SharedViews设置为alpha&#x3D;1</li>
<li>SharedView的位置和大小被设置为启动Activity对应Views的原始状态</li>
<li>开始共享元素动画</li>
<li>发送<code>MSG_HIDE_SHARED_ELEMENTS</code>给ExitTransitionCoordinator通知启动Activity隐藏对应的SharedViews</li>
</ul>
</li>
<li>ExitTransitionCoordinator同时发送<code>MSG_EXIT_TRANSITION_COMPLETE</code>给EnterTransitionCoordinator，通知它可以开始EnterTransition动画(不是SharedEnterTransitino)</li>
<li>动画结束后Activity A回调<code>onStop()</code>触发被隐藏的Views恢复显示</li>
</ol>
<!-- <p class="img-tip" data-str="image.png"><img src='/images/shared3.png' height=250/></p> -->
<p><img src="/images/shared3.png"></p>
<h2 id="Activity-A的Shared-Views是怎么传递给Activity-B的"><a href="#Activity-A的Shared-Views是怎么传递给Activity-B的" class="headerlink" title="Activity A的Shared Views是怎么传递给Activity B的"></a>Activity A的Shared Views是怎么传递给Activity B的</h2><p>其实传递View这种说法并不准确，准确来说是将View的相关参数传递给Activity B，使得Activity B可以根据这些参数来构造出和Activity A上一样的View。<br>首先ExitTransitionCoordinator会在构造方法中调用父类的<code>viewsReady(mapSharedElements(accepted, mapped))</code>方法来收集当前Activity参与共享元素动画的所有View，并赋值给mSharedElements和mSharedElementNames，分别表示共享元素View和对应Name的集合，同时获取当前Activity中所有可见性为Visible的View并赋值给mTransitionViews</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExitTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">protected</span> ArrayMap&lt;String, View&gt; <span class="title function_">mapSharedElements</span><span class="params">(ArrayList&lt;String&gt; accepted,</span></span><br><span class="line"><span class="params">        ArrayList&lt;View&gt; localViews)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (decorView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历child获得所有transitionName不为空且Visible的View</span></span><br><span class="line">        decorView.findNamedViews(sharedElements);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sharedElements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">viewsReady</span><span class="params">(ArrayMap&lt;String, View&gt; sharedElements)</span> &#123;</span><br><span class="line">    sharedElements.retainAll(mAllSharedElementNames);</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mListener.onMapSharedElements(mAllSharedElementNames, sharedElements);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将mSharedElements和mSharedElementNames赋值</span></span><br><span class="line">    setSharedElements(sharedElements);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (decorView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取所有Visibile的View到mTransitioningViews中</span></span><br><span class="line">        decorView.captureTransitioningViews(mTransitioningViews);</span><br><span class="line">    &#125;</span><br><span class="line">    mTransitioningViews.removeAll(mSharedElements);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后ExitTransitionCoordinator会在ExitTransition执行完毕后会触发<code>captureSharedElementState()</code>来构造共享元素的相关参数，返回一个Bundle赋值给mSharedElementBundle，然后调用<code>notifyComplete()</code>将mSharedElementBundle发送给Activity B的EnterTransitionCoordinator通知可以开始动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">notifyComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// resultReceiver就是Activity B的EnterTransitionCoordinator</span></span><br><span class="line">    resultReceiver.send(MSG_TAKE_SHARED_ELEMENTS, sharedElementBundle);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们着重查看<code>captureSharedElementState()</code>方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExitTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">protected</span> Bundle <span class="title function_">captureSharedElementState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    <span class="type">RectF</span> <span class="variable">tempBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">    <span class="type">Matrix</span> <span class="variable">tempMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mSharedElements.size(); i++) &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">sharedElement</span> <span class="operator">=</span> mSharedElements.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> mSharedElementNames.get(i);</span><br><span class="line">        captureSharedElementState(sharedElement, name, bundle, tempMatrix, tempBounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bundle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">captureSharedElementState</span><span class="params">(View view, String name, Bundle transitionArgs,</span></span><br><span class="line"><span class="params">        Matrix tempMatrix, RectF tempBounds)</span> &#123;</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">sharedElementBundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    tempMatrix.reset();</span><br><span class="line">    view.transformMatrixToGlobal(tempMatrix);</span><br><span class="line">    tempBounds.set(<span class="number">0</span>, <span class="number">0</span>, view.getWidth(), view.getHeight());</span><br><span class="line">    tempMatrix.mapRect(tempBounds);</span><br><span class="line"></span><br><span class="line">    sharedElementBundle.putFloat(KEY_SCREEN_LEFT, tempBounds.left);</span><br><span class="line">    sharedElementBundle.putFloat(KEY_SCREEN_RIGHT, tempBounds.right);</span><br><span class="line">    sharedElementBundle.putFloat(KEY_SCREEN_TOP, tempBounds.top);</span><br><span class="line">    sharedElementBundle.putFloat(KEY_SCREEN_BOTTOM, tempBounds.bottom);</span><br><span class="line">    sharedElementBundle.putFloat(KEY_TRANSLATION_Z, view.getTranslationZ());</span><br><span class="line">    sharedElementBundle.putFloat(KEY_ELEVATION, view.getElevation());</span><br><span class="line">    <span class="comment">// 忽略对ImageView的特殊处理</span></span><br><span class="line">    ...</span><br><span class="line">    transitionArgs.putBundle(name, sharedElementBundle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是遍历mSharedElements和mSharedElementNames通过<code>captureSharedElementState(View, String, Bundle, Matrix, RectF)</code>来更新每一个共享元素的State到Bundle中。最关键的就是将left、top、right、bottom参数放入bundle中传递给Activity B，然而这里的参数并不是通过<code>View#getLeft()</code>等方法拿到的，而是通过一些运算得到的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tempMatrix.reset();</span><br><span class="line">view.transformMatrixToGlobal(tempMatrix);</span><br><span class="line">tempBounds.set(<span class="number">0</span>, <span class="number">0</span>, view.getWidth(), view.getHeight());</span><br><span class="line">tempMatrix.mapRect(tempBounds);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transformMatrixToGlobal</span><span class="params">(Matrix m)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ViewParent</span> <span class="variable">parent</span> <span class="operator">=</span> mParent;</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">vp</span> <span class="operator">=</span> (View) parent;</span><br><span class="line">        vp.transformMatrixToGlobal(m);</span><br><span class="line">        m.preTranslate(-vp.mScrollX, -vp.mScrollY);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewRootImpl) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewRootImpl</span> <span class="variable">vr</span> <span class="operator">=</span> (ViewRootImpl) parent;</span><br><span class="line">        vr.transformMatrixToGlobal(m);</span><br><span class="line">        m.preTranslate(<span class="number">0</span>, -vr.mCurScrollY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.preTranslate(mLeft, mTop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将m前乘view.getMatrix是为了避免本身自带的Matrix造成的误差</span></span><br><span class="line">    <span class="keyword">if</span> (!hasIdentityMatrix()) &#123;</span><br><span class="line">        m.preConcat(getMatrix());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transformMatrixToGlobal</span><span class="params">(Matrix m)</span> &#123;</span><br><span class="line">    m.preTranslate(mAttachInfo.mWindowLeft, mAttachInfo.mWindowTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们查看<code>View#transformMatrixToGlobal()</code>方法可以看出内部是向上遍历调用Parent的<code>transformMatrixToGlobal</code>方法直到ViewRootImpl，然后将由Parent处理后的Matrix做<code>preTranslate(mLeft, mTop)</code>操作，而<code>ViewRootImpl#transformMatrixToGlobal</code>方法也是对Metrix做preTranslate，距离是当前Window在屏幕上的left&#x2F;top，所以一般来说该方法返回的是所有Parent的preTranslate(mLeft, mTop)叠加结果，返回的Matrix为</p>

$$
\left\{
 \begin{matrix}
   1 & 0 & leftOnScreen \\
   0 & 1 & topOnScreen \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
$$


<p>其中leftOnScreen和topOnScreen就是该View距离屏幕的左边&#x2F;上边的距离。<br>但是真实情况返回Matrix的不一定是这样，因为View自身的Matrix可能并不是一个单位矩阵(设置过scale&#x2F;rotation等)，所以在拿到处理过的matrix后还需要做一次变换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!hasIdentityMatrix()) &#123;</span><br><span class="line">    m.preConcat(getMatrix());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这样处理后的Matrix作用于<code>rect = [0, 0, view.getWidth(), view.getHeight()]</code>的矩形就能够得到<strong>视觉上</strong>该View在屏幕上的坐标。</p>
<!-- <p class="img-tip" data-str="image.png"><img src='/images/shared4.png' height=540 width=864/></p> -->
<p><img src="/images/shared4.png"></p>
<p>我们举个例子来说明这个方法，假设图中A代表屏幕，B为一个ViewGroup，左上角在A中的坐标为(100, 100)，C长宽均为100，是B的child view，左上角在B中的坐标是(50, 50)，同时C设置了transaltion，x、y均偏移25也就是图中灰色的区域(绿色区域为C的真实位置)。C的<code>transformMatrixToGlobal</code>方法中首先获取到Parent也就是B的Matrix，得到的是x、y偏移100的矩阵</p>

$$
B=
\left\{
 \begin{matrix}
   1 & 0 & 100 \\
   0 & 1 & 100 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
$$

<p>随后将矩阵B偏移C在Parent中的left&#x2F;top</p>

$$
C=
\left\{
 \begin{matrix}
   1 & 0 & 100 \\
   0 & 1 & 100 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
*
\left\{
 \begin{matrix}
   1 & 0 & 50 \\
   0 & 1 & 50 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
=
\left\{
 \begin{matrix}
   1 & 0 & 150 \\
   0 & 1 & 150 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
$$

<p>因为C本身设置了translation，所以自身有一个非单位矩阵，将C乘以该矩阵得到最终的矩阵C2</p>

$$
C2=
\left\{
 \begin{matrix}
   1 & 0 & 150 \\
   0 & 1 & 150 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
*
\left\{
 \begin{matrix}
   1 & 0 & 25 \\
   0 & 1 & 25 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
=
\left\{
 \begin{matrix}
   1 & 0 & 175 \\
   0 & 1 & 175 \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
$$

<p>可以看出该矩阵的作用就是将坐标在x、y方向上移动175的距离，将该矩阵作用于长宽与C一样的矩形(0, 0, 100, 100)得到的就是我们看到的灰色区域，所以该方法最后得到的就是我们所能看到的View在屏幕上的坐标(而不是真正的坐标)。</p>
<p>看到这里大家一定有一个疑问，为什么不直接用getLocationOnScreen方法？其实这两种方法是有差别的。一方面getLocationOnScreen只能获得该View左上角在屏幕中的坐标而无法获得View右下角在屏幕中的坐标，另一方面如果View或者View的Parent设置了rotation，那么就会导致getLocationOnScreen方法获取不准确，因为getLocationOnScreen方法内部实现是针对点来做矩阵变换的，这样就会导致带有rotation的矩阵将左上角的点(0, 0)进行旋转，进而导致结果不准确。而<code>transformMatrixToGlobal</code>方法直接返回作用的Matrix，我们将该Matrix作用在矩形上，就可以获取准确的坐标。<br>总结：Activity A传递给Activity B的是<strong>视觉上</strong>Shared Views在屏幕中的坐标。 </p>
<h2 id="Activity-B的是怎么处理Activity-A传递的Bundle并实现动画"><a href="#Activity-B的是怎么处理Activity-A传递的Bundle并实现动画" class="headerlink" title="Activity B的是怎么处理Activity A传递的Bundle并实现动画"></a>Activity B的是怎么处理Activity A传递的Bundle并实现动画</h2><p>上文提到ExitTransitionCoordiantor的exit动画结束后会发送<code>MSG_TAKE_SHARED_ELEMENTS</code>给被启动Activity的EnterTransitionCoordinator通知它可以开始动画，在EnterTransitionCoordinator中将执行<code>startSharedElementTransition</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onReceiveResult</span><span class="params">(<span class="type">int</span> resultCode, Bundle resultData)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (resultCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_TAKE_SHARED_ELEMENTS:</span><br><span class="line">            <span class="keyword">if</span> (!mIsCanceled) &#123;</span><br><span class="line">                mSharedElementsBundle = resultData;</span><br><span class="line">                onTakeSharedElements();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onTakeSharedElements</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mIsReadyForTransition || mSharedElementsBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Bundle</span> <span class="variable">sharedElementState</span> <span class="operator">=</span> mSharedElementsBundle;</span><br><span class="line">    mSharedElementsBundle = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OnSharedElementsReadyListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OnSharedElementsReadyListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSharedElementsReady</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">decorView</span> <span class="operator">=</span> getDecor();</span><br><span class="line">            <span class="keyword">if</span> (decorView != <span class="literal">null</span>) &#123;</span><br><span class="line">                OneShotPreDrawListener.add(decorView, <span class="literal">false</span>, () -&gt; &#123;</span><br><span class="line">                    startTransition(() -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 将Activity A传递过来的带有View参数的bundle传递，并开始动画</span></span><br><span class="line">                            startSharedElementTransition(sharedElementState);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                decorView.invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (mListener == <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.onSharedElementsReady();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mListener.onSharedElementsArrived(mSharedElementNames, mSharedElements, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们着重关注startSharedElementTransition方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSharedElementTransition</span><span class="params">(Bundle sharedElementState)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Now start shared element transition</span></span><br><span class="line">    ArrayList&lt;View&gt; sharedElementSnapshots = createSnapshots(sharedElementState,</span><br><span class="line">            mSharedElementNames);</span><br><span class="line">    showViews(mSharedElements, <span class="literal">true</span>);</span><br><span class="line">    scheduleSetSharedElementEnd(sharedElementSnapshots);</span><br><span class="line">    <span class="comment">// 将Activity B上的Shared Views设置为Activity A上的初始状态，并返回在Activity B中的原始状态</span></span><br><span class="line">    ArrayList&lt;SharedElementOriginalState&gt; originalImageViewState =</span><br><span class="line">            setSharedElementState(sharedElementState, sharedElementSnapshots);</span><br><span class="line">    requestLayoutForSharedElements();</span><br><span class="line">    ...</span><br><span class="line">    setGhostVisibility(View.INVISIBLE);</span><br><span class="line">    scheduleGhostVisibilityChange(View.INVISIBLE);</span><br><span class="line">    pauseInput();</span><br><span class="line">    <span class="comment">// 开始动画</span></span><br><span class="line">    <span class="type">Transition</span> <span class="variable">transition</span> <span class="operator">=</span> beginTransition(decorView, startEnterTransition,</span><br><span class="line">            startSharedElementTransition);</span><br><span class="line">    scheduleGhostVisibilityChange(View.VISIBLE);</span><br><span class="line">    setGhostVisibility(View.VISIBLE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将Views设置为原始状态，触发Transition 捕获起始状态&amp;创建/执行动画</span></span><br><span class="line">    setOriginalSharedElementState(mSharedElements, originalImageViewState);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调整Shared-Views为Activity-A上的初始状态"><a href="#调整Shared-Views为Activity-A上的初始状态" class="headerlink" title="调整Shared Views为Activity A上的初始状态"></a>调整Shared Views为Activity A上的初始状态</h3><p>从上面的代码可以看到首先调用了setSharedElementState方法，该方法将Shared Views通过传递来的bundle调整为初始状态，返回的originalImageViewState是Shared Views在Activity B中的原始状态，也就是动画的结束状态，用于后续的恢复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">protected</span> ArrayList&lt;SharedElementOriginalState&gt; <span class="title function_">setSharedElementState</span><span class="params">(</span></span><br><span class="line"><span class="params">        Bundle sharedElementState, <span class="keyword">final</span> ArrayList&lt;View&gt; snapshots)</span> &#123;</span><br><span class="line">    ArrayList&lt;SharedElementOriginalState&gt; originalImageState =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SharedElementOriginalState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (sharedElementState != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">tempMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">        <span class="type">RectF</span> <span class="variable">tempRect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">numSharedElements</span> <span class="operator">=</span> mSharedElements.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numSharedElements; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">sharedElement</span> <span class="operator">=</span> mSharedElements.get(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> mSharedElementNames.get(i);</span><br><span class="line">            <span class="type">SharedElementOriginalState</span> <span class="variable">originalState</span> <span class="operator">=</span> getOldSharedElementState(sharedElement,</span><br><span class="line">                    name, sharedElementState);</span><br><span class="line">            originalImageState.add(originalState);</span><br><span class="line">            setSharedElementState(sharedElement, name, sharedElementState,</span><br><span class="line">                    tempMatrix, tempRect, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mListener.onSharedElementStart(mSharedElementNames, mSharedElements, snapshots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalImageState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部其实就是遍历所有的Shared View，针对每个View先获取oldState保存，然后设置为动画初始状态。在getOldSharedElementState内部只是简单的保存了left&#x2F;top等信息，我们着重看一下将View设置为初始状态的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSharedElementState</span><span class="params">(View view, String name, Bundle transitionArgs,</span></span><br><span class="line"><span class="params">        Matrix tempMatrix, RectF tempRect, <span class="type">int</span>[] decorLoc)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里省略针对ImageView的特殊处理</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> <span class="variable">left</span> <span class="operator">=</span> sharedElementBundle.getFloat(KEY_SCREEN_LEFT);</span><br><span class="line">    <span class="type">float</span> <span class="variable">top</span> <span class="operator">=</span> sharedElementBundle.getFloat(KEY_SCREEN_TOP);</span><br><span class="line">    <span class="type">float</span> <span class="variable">right</span> <span class="operator">=</span> sharedElementBundle.getFloat(KEY_SCREEN_RIGHT);</span><br><span class="line">    <span class="type">float</span> <span class="variable">bottom</span> <span class="operator">=</span> sharedElementBundle.getFloat(KEY_SCREEN_BOTTOM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decorLoc != <span class="literal">null</span>) &#123;</span><br><span class="line">        left -= decorLoc[<span class="number">0</span>];</span><br><span class="line">        top -= decorLoc[<span class="number">1</span>];</span><br><span class="line">        right -= decorLoc[<span class="number">0</span>];</span><br><span class="line">        bottom -= decorLoc[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the location in the view&#x27;s parent</span></span><br><span class="line">        getSharedElementParentMatrix(view, tempMatrix);</span><br><span class="line">        tempRect.set(left, top, right, bottom);</span><br><span class="line">        tempMatrix.mapRect(tempRect);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">leftInParent</span> <span class="operator">=</span> tempRect.left;</span><br><span class="line">        <span class="type">float</span> <span class="variable">topInParent</span> <span class="operator">=</span> tempRect.top;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the size of the view</span></span><br><span class="line">        view.getInverseMatrix().mapRect(tempRect);</span><br><span class="line">        <span class="type">float</span> <span class="variable">width</span> <span class="operator">=</span> tempRect.width();</span><br><span class="line">        <span class="type">float</span> <span class="variable">height</span> <span class="operator">=</span> tempRect.height();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now determine the offset due to view transform:</span></span><br><span class="line">        view.setLeft(<span class="number">0</span>);</span><br><span class="line">        view.setTop(<span class="number">0</span>);</span><br><span class="line">        view.setRight(Math.round(width));</span><br><span class="line">        view.setBottom(Math.round(height));</span><br><span class="line">        tempRect.set(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        view.getMatrix().mapRect(tempRect);</span><br><span class="line"></span><br><span class="line">        left = leftInParent - tempRect.left;</span><br><span class="line">        top = topInParent - tempRect.top;</span><br><span class="line">        right = left + width;</span><br><span class="line">        bottom = top + height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.round(left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Math.round(top);</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> Math.round(right) - x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.round(bottom) - y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">widthSpec</span> <span class="operator">=</span> View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY);</span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSpec</span> <span class="operator">=</span> View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);</span><br><span class="line">    view.measure(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">    view.layout(x, y, x + width, y + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又涉及到一些矩阵知识了，首先是拿到Activity A传过来的View的left&#x2F;top&#x2F;right&#x2F;bottom参数(在屏幕上的)，这里我们是不能直接设置给Activity B的View，因为Activity B的View依赖于它的Parent，所以我们首先将屏幕上的坐标转换为在Parent中的坐标，通过<code>getSharedElementParentMatrix(view, tempMatrix)</code>来拿到转换的Matrix对tempRect进行转换，我们看看getSharedElementParentMatrix的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSharedElementParentMatrix</span><span class="params">(View view, Matrix matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mSharedElementParentMatrices == <span class="literal">null</span> ? -<span class="number">1</span></span><br><span class="line">            : mSharedElements.indexOf(view);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        matrix.reset();</span><br><span class="line">        <span class="type">ViewParent</span> <span class="variable">viewParent</span> <span class="operator">=</span> view.getParent();</span><br><span class="line">        <span class="keyword">if</span> (viewParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">            <span class="comment">// Find the location in the view&#x27;s parent</span></span><br><span class="line">            <span class="type">ViewGroup</span> <span class="variable">parent</span> <span class="operator">=</span> (ViewGroup) viewParent;</span><br><span class="line">            parent.transformMatrixToLocal(matrix);</span><br><span class="line">            matrix.postTranslate(parent.getScrollX(), parent.getScrollY());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The indices of mSharedElementParentMatrices matches the</span></span><br><span class="line">        <span class="comment">// mSharedElement matrices.</span></span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">parentMatrix</span> <span class="operator">=</span> mSharedElementParentMatrices.get(index);</span><br><span class="line">        matrix.set(parentMatrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<strong>Parent</strong>的<code>transformMatrixToLocal</code>方法来获得转换矩阵，这和之前提到的<code>transformMatrixToGlobal</code>方法实现非常相似，这里说结论，<code>transformMatrixToLocal</code>返回的Matrix和<code>transformMatrixToGlobal</code>相反，一般返回的Matrix如下所示(除去View自身Matrix的影响的话)</p>

$$
\left\{
 \begin{matrix}
   1 & 0 & -leftOnScreen \\
   0 & 1 & -topOnScreen \\
   0 & 0 & 1 \\
 \end{matrix} 
\right\}
$$

<p>其中leftOnScreen和topOnScreen就是该Parent距离屏幕的左&#x2F;上的距离。经过此Matrix转换后tempRect的坐标就是我们所期望的View在Parent中的坐标了，但是仍然不能直接设置给View！如果假设View本身设置过Scale&#x3D;2，那么当将计算后的坐标设置给View时会在正常大小上再作用一个Scale&#x3D;2，显示的效果就是预期的两倍，所以我们还需要以下操作：</p>
<ol>
<li>计算我们需要设置的真正width&#x2F;height：通过拿到View的逆矩阵应用到tempRect上可以得到我们实际需要设置的width&#x2F;height</li>
<li>计算真正的left&#x2F;top：之前我们已经计算出视觉上我们的View在Parent中的left和top，但是因为View自身的Matrix影响，我们需要计算出该矩阵应用于矩形后会导致矩形的left&#x2F;top相比原来偏移多少，然后在设置left&#x2F;top的时候减去这个偏差</li>
</ol>
<h3 id="调整Shared-Views为最终状态"><a href="#调整Shared-Views为最终状态" class="headerlink" title="调整Shared Views为最终状态"></a>调整Shared Views为最终状态</h3><p>共享元素动画使用的是Transition框架，我们只要调整View的状态，就可以自动捕获初始状态&#x2F;结束状态来生成动画，所以后面要做的就是将SharedViews调整成最初的状态(也就是在Activity B中的最终状态)。从上面的<code>startSharedElementTransition</code>实现来看，首先调用<code>beginTransition</code>方法，内部调用了<code>TransitionManager.beginDelayedTransition(decorView, transition)</code>来开始动画，随后调用<code>setOriginalSharedElementState(mSharedElements, originalImageViewState)</code>来将Shared Views设置为最终状态，我们来看下这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOriginalSharedElementState</span><span class="params">(ArrayList&lt;View&gt; sharedElements,</span></span><br><span class="line"><span class="params">        ArrayList&lt;SharedElementOriginalState&gt; originalState)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; originalState.size(); i++) &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> sharedElements.get(i);</span><br><span class="line">        <span class="type">SharedElementOriginalState</span> <span class="variable">state</span> <span class="operator">=</span> originalState.get(i);</span><br><span class="line">        <span class="comment">// 忽略对ImageView的特殊处理</span></span><br><span class="line">        ...</span><br><span class="line">        view.setElevation(state.mElevation);</span><br><span class="line">        view.setTranslationZ(state.mTranslationZ);</span><br><span class="line">        <span class="type">int</span> <span class="variable">widthSpec</span> <span class="operator">=</span> View.MeasureSpec.makeMeasureSpec(state.mMeasuredWidth,</span><br><span class="line">                View.MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="type">int</span> <span class="variable">heightSpec</span> <span class="operator">=</span> View.MeasureSpec.makeMeasureSpec(state.mMeasuredHeight,</span><br><span class="line">                View.MeasureSpec.EXACTLY);</span><br><span class="line">        view.measure(widthSpec, heightSpec);</span><br><span class="line">        view.layout(state.mLeft, state.mTop, state.mRight, state.mBottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>originState就是之前调用<code>setSharedElementState</code>返回的原始状态，我们就是通过这个state来恢复View的状态的，实现就只是简单的measure、layout。</p>
<h2 id="参与动画的元素是怎么能够保证不被遮挡的"><a href="#参与动画的元素是怎么能够保证不被遮挡的" class="headerlink" title="参与动画的元素是怎么能够保证不被遮挡的"></a>参与动画的元素是怎么能够保证不被遮挡的</h2><p>看到这里其实可以知道一点，参与动画的元素都是Activity B上的View，从A过渡过来的效果不过是将B上的View进行转换而已，但是B上的View都是依赖于它的Parent，而动画的初始状态的位置又不能保证在该Parent的可视区域内，按照正常流程，Shared Views很大概率是会在动画过程中移动到不可见区域导致View不可见，所以我们需要将Shared Views移动到屏幕顶层，也就是ViewGroupOverlay层。</p>
<h3 id="GhostView"><a href="#GhostView" class="headerlink" title="GhostView"></a>GhostView</h3><p>我们直接使用ViewGroupOverlay会有一个问题，<code>ViewGroupOverlay#add(View v)</code>方法会将view从原有的Parent中remove，再添加到ViewGroupOverlay中，可是我们并不希望改变View原有的层级结构，毕竟动画结束后所有View需要恢复原样，所以Android提供了GhostView对ViewOverlay进行了封装，通过调用<code>GhostViet#addGhost</code>方法来将View添加到ViewOverlay层，且能够保持原来的View不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GhostView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas <span class="keyword">instanceof</span> DisplayListCanvas) &#123;</span><br><span class="line">        <span class="type">DisplayListCanvas</span> <span class="variable">dlCanvas</span> <span class="operator">=</span> (DisplayListCanvas) canvas;</span><br><span class="line">        mView.mRecreateDisplayList = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> mView.updateDisplayListIfDirty();</span><br><span class="line">        <span class="keyword">if</span> (renderNode.isValid()) &#123;</span><br><span class="line">            dlCanvas.insertReorderBarrier(); <span class="comment">// enable shadow for this rendernode</span></span><br><span class="line">            dlCanvas.drawRenderNode(renderNode);</span><br><span class="line">            dlCanvas.insertInorderBarrier(); <span class="comment">// re-disable reordering/shadows</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实GhostView添加到ViewOverlay的并不是原来的View，而是自己创建的FrameLayout，然后在绘制的时候获取View的renderNode来对自己的canvas进行绘制，达到视觉上和View一摸一样的目的，并且每次View有改变都会通知到GhostView来绘制</p>
<h3 id="使用GhostView后如何保证添加到ViewGroupOverlay的元素与不添加之前层级保持一致"><a href="#使用GhostView后如何保证添加到ViewGroupOverlay的元素与不添加之前层级保持一致" class="headerlink" title="使用GhostView后如何保证添加到ViewGroupOverlay的元素与不添加之前层级保持一致"></a>使用GhostView后如何保证添加到ViewGroupOverlay的元素与不添加之前层级保持一致</h3><p>我们使用GhostView的时候是将各个View加到Overlay上，但是GhostView是怎么保证View在视觉上的顺序和View在正常布局中的顺序一致的呢？我们发现<code>GhostView#add</code>方法中这么两行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">firstGhost</span> <span class="operator">=</span> moveGhostViewsToTop(overlay.mOverlayViewGroup, tempViews);</span><br><span class="line">insertIntoOverlay(overlay.mOverlayViewGroup, parent, ghostView, tempViews, firstGhost);</span><br></pre></td></tr></table></figure>
<p>由于获得的ViewOverlay中可能存在其他地方加进来的View，所以首先通<code>moveGhostViewsToTop</code>方法遍历其中所有的View，然后将所有GhostView重新add到ViewOverlay中保证GhostView覆盖在最上层。随后就是真正的add操作了，<code>insertIntoOverlay</code>内部其实是通过二分法来找到View插入的index，判断依据是View是否会被绘制在被比较View的上方，通过<code>isOnTop方</code>法来判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GhostView.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个View的Paren队列来判断前者是否在后者上方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOnTop</span><span class="params">(ArrayList&lt;View&gt; viewParents, ArrayList&lt;View&gt; comparedWith)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (viewParents.isEmpty() || comparedWith.isEmpty() ||</span><br><span class="line">            viewParents.get(<span class="number">0</span>) != comparedWith.get(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Not the same decorView -- arbitrary ordering</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> Math.min(viewParents.size(), comparedWith.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; depth; i++) &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">viewParent</span> <span class="operator">=</span> viewParents.get(i);</span><br><span class="line">        <span class="type">View</span> <span class="variable">comparedWithParent</span> <span class="operator">=</span> comparedWith.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewParent != comparedWithParent) &#123;</span><br><span class="line">            <span class="comment">// i - 1 is the same parent, but these are different children.</span></span><br><span class="line">            <span class="comment">// 走到这说明两者在同一个View的层级下，那么根据在Parent中的顺序来判断</span></span><br><span class="line">            <span class="keyword">return</span> isOnTop(viewParent, comparedWithParent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这说明两者截取长度为depth的Parent队列一摸一样，</span></span><br><span class="line">    <span class="comment">// 说明真实队列较长的View是另一个View的Child(或者是另一个View同级的View的child)，也就说明在屏幕上更加靠前</span></span><br><span class="line">    <span class="comment">// one of these is the parent of the other</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isComparedWithTheParent</span> <span class="operator">=</span> (comparedWith.size() == depth);</span><br><span class="line">    <span class="keyword">return</span> isComparedWithTheParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现是将两个View的Parent队列(包括本身)做比较，首先将较长队列截取为长度和较短队列一致，然后遍历比较，会出现以下两种情况</p>
<ul>
<li>截取后的两个队列一摸一样：那么较长的队列的View必然是另一队列View的child，自然比parent更加靠上</li>
<li>截取后的两个队列在某一节点开始不一样：那么只要判断这两个节点的层级就可以了，通过调用<code>isOnTop(View, View)</code>来判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOnTop</span><span class="params">(View view, View comparedWith)</span> &#123;</span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">parent</span> <span class="operator">=</span> (ViewGroup) view.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> parent.getChildCount();</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = parent.buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">customOrder</span> <span class="operator">=</span> preorderedList == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; parent.isChildrenDrawingOrderEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This default value shouldn&#x27;t be used because both view and comparedWith</span></span><br><span class="line">    <span class="comment">// should be in the list. If there is an error, then just return an arbitrary</span></span><br><span class="line">    <span class="comment">// view is on top.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isOnTop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> customOrder ? parent.getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> (preorderedList == <span class="literal">null</span>)</span><br><span class="line">                ? parent.getChildAt(childIndex) : preorderedList.get(childIndex);</span><br><span class="line">        <span class="keyword">if</span> (child == view) &#123;</span><br><span class="line">            isOnTop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == comparedWith) &#123;</span><br><span class="line">            isOnTop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">        preorderedList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法判断两个View绘制层级的逻辑和<code>ViewGroup#dispatchDraw</code>是一样的，有兴趣的同学可以深入研究一下。</p>
<h2 id="动画过程中其余元素的状态如何"><a href="#动画过程中其余元素的状态如何" class="headerlink" title="动画过程中其余元素的状态如何"></a>动画过程中其余元素的状态如何</h2><p>上文提到除去Shared Views其余可见性为Visible的View都会被添加到mTransitioningViews中，本节我们看看动画过程中这些View的状态是怎么样的。我们从<code>EnterTransitionCoordinator#viewsReady()</code>方法入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">viewsReady</span><span class="params">(ArrayMap&lt;String, View&gt; sharedElements)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.viewsReady(sharedElements);</span><br><span class="line">    mIsReadyForTransition = <span class="literal">true</span>;</span><br><span class="line">    hideViews(mSharedElements);</span><br><span class="line">    <span class="type">Transition</span> <span class="variable">viewsTransition</span> <span class="operator">=</span> getViewsTransition();</span><br><span class="line">    <span class="keyword">if</span> (viewsTransition != <span class="literal">null</span> &amp;&amp; mTransitioningViews != <span class="literal">null</span>) &#123;</span><br><span class="line">        removeExcludedViews(viewsTransition, mTransitioningViews);</span><br><span class="line">        stripOffscreenViews();</span><br><span class="line">        hideViews(mTransitioningViews);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mIsReturning) &#123;</span><br><span class="line">        sendSharedElementDestination();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moveSharedElementsToOverlay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSharedElementsBundle != <span class="literal">null</span>) &#123;</span><br><span class="line">        onTakeSharedElements();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现可以看出首先将mTransitioningViews隐藏，将view的alpha设置为0。真正进行动画是在<code>startSharedElementTransition</code>方法中进行，其中调用了<code>beginTransition</code>方法开始真正的动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">private</span> Transition <span class="title function_">beginTransition</span><span class="params">(ViewGroup decorView, <span class="type">boolean</span> startEnterTransition,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> startSharedElementTransition)</span> &#123;</span><br><span class="line">    <span class="type">Transition</span> <span class="variable">sharedElementTransition</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 忽略共享元素动画</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Transition</span> <span class="variable">viewsTransition</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (startEnterTransition) &#123;</span><br><span class="line">        mIsViewsTransitionStarted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTransitioningViews != <span class="literal">null</span> &amp;&amp; !mTransitioningViews.isEmpty()) &#123;</span><br><span class="line">            viewsTransition = configureTransition(getViewsTransition(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (viewsTransition == <span class="literal">null</span>) &#123;</span><br><span class="line">            viewsTransitionComplete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; transitioningViews = mTransitioningViews;</span><br><span class="line">            viewsTransition.addListener(<span class="keyword">new</span> <span class="title class_">ContinueTransitionListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTransitionStart</span><span class="params">(Transition transition)</span> &#123;</span><br><span class="line">                    mEnterViewsTransition = transition;</span><br><span class="line">                    <span class="keyword">if</span> (transitioningViews != <span class="literal">null</span>) &#123;</span><br><span class="line">                        showViews(transitioningViews, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">super</span>.onTransitionStart(transition);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTransitionEnd</span><span class="params">(Transition transition)</span> &#123;</span><br><span class="line">                    mEnterViewsTransition = <span class="literal">null</span>;</span><br><span class="line">                    transition.removeListener(<span class="built_in">this</span>);</span><br><span class="line">                    viewsTransitionComplete();</span><br><span class="line">                    <span class="built_in">super</span>.onTransitionEnd(transition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Transition</span> <span class="variable">transition</span> <span class="operator">=</span> mergeTransitions(sharedElementTransition, viewsTransition);</span><br><span class="line">    <span class="keyword">if</span> (transition != <span class="literal">null</span>) &#123;</span><br><span class="line">        transition.addListener(<span class="keyword">new</span> <span class="title class_">ContinueTransitionListener</span>());</span><br><span class="line">        <span class="keyword">if</span> (startEnterTransition) &#123;</span><br><span class="line">            setTransitioningViewsVisiblity(View.INVISIBLE, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        TransitionManager.beginDelayedTransition(decorView, transition);</span><br><span class="line">        <span class="keyword">if</span> (startEnterTransition) &#123;</span><br><span class="line">            setTransitioningViewsVisiblity(View.VISIBLE, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        decorView.invalidate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transitionStarted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其余的View的动画是通过<code>getEnterTransition</code>获得的，和Shared Transition同时进行，但是该方法传入了一个参数来判断是否进行enterTransition，该参数在<code>startSharedElementTransition</code>获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">startEnterTransition</span> <span class="operator">=</span> allowOverlappingTransitions() &amp;&amp; !mIsReturning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">allowOverlappingTransitions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mIsReturning ? getWindow().getAllowReturnTransitionOverlap()</span><br><span class="line">            : getWindow().getAllowEnterTransitionOverlap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>window#getAllowEnterTransitionOverlap()</code>来判断是否进行enterTransition，该方法表示是否允许enterTransition尽可能早的执行，如果为True将和Shared Transition一起进行，如果为false呢？那么就会在<code>EnterTransitionCoordinator#onRemoteExitTransitionComplete</code>方法中被触发执行，该方法是被ExitTransitionCoordiantor通过<code>notifyComplete</code>触发的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">notifyComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mResultReceiver.send(MSG_TAKE_SHARED_ELEMENTS, mSharedElementBundle);</span><br><span class="line">    notifyExitComplete();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见在EnterTransitionCoordinator执行Shared Transition动画后立马触发EnterTransition的动画(如果EnterTransitionOverlap为false)，视觉上差别不会很大</p>
<h2 id="默认的动画是在哪里设置的"><a href="#默认的动画是在哪里设置的" class="headerlink" title="默认的动画是在哪里设置的"></a>默认的动画是在哪里设置的</h2><p>无论是共享元素动画还是EnterTransition都是从Window中获取的，我们并没有手动设置也可以生效，那是因为Window在加载的时候默认加载了动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PhoneWindow.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mEnterTransition = getTransition(mEnterTransition, <span class="literal">null</span>, R.styleable.Window_windowEnterTransition);</span><br><span class="line">    ...</span><br><span class="line">    mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, <span class="literal">null</span>, R.styleable.Window_windowSharedElementEnterTransition);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见是通过<code>windowEnterTransition/windowSharedElementEnterTransition</code>来获取的，在<code>sdk/platforms/android-28/data/res/values/themes_material.xml</code>文件中找到定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeBounds</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeTransform</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeClipBounds</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeImageTransform</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出默认的Shared Transition是四个Transition的集合，其中默认支持ImageView的tranform。</p>
<h2 id="其余元素在动画过程中被Shared-Views覆盖怎么办"><a href="#其余元素在动画过程中被Shared-Views覆盖怎么办" class="headerlink" title="其余元素在动画过程中被Shared Views覆盖怎么办"></a>其余元素在动画过程中被Shared Views覆盖怎么办</h2><p>从最开始的Demo 录屏可以看出Activity B左下角的Button展示后会被参与共享元素动画的背景封面遮挡，动画结束后才再次显示出来，这是因为Shared Views都被显示到ViewGroupOverlay中了，所以会覆盖Button，动画结束后回到正常的View层级中Button才能显示。为了解决这个问题我们可以将Button也加入到共享元素中去，这样Button也会显示到ViewOverlay中，就不会被覆盖了。</p>
<h3 id="怎么将View加入到共享元素中去"><a href="#怎么将View加入到共享元素中去" class="headerlink" title="怎么将View加入到共享元素中去"></a>怎么将View加入到共享元素中去</h3><p>如果我们使用之前的办法，给Button加上transitionName，会发现行不通，因为在收集Shared View的时候会针对Activity A传递过来的name来做去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnterTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">viewsReady</span><span class="params">(ArrayMap&lt;String, View&gt; sharedElements)</span> &#123;</span><br><span class="line">    <span class="comment">// 将sharedElements中不存在于mAllSharedElementNames中的元素删除</span></span><br><span class="line">    sharedElements.retainAll(mAllSharedElementNames);</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mListener.onMapSharedElements(mAllSharedElementNames, sharedElements);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们可以发现后面又调用了<code>mListener#onMapSharedElements</code>方法来添加Shared Views，该Listener类型为SharedElementCallback，我们可以通过activity来设置Listener并重写<code>onMapSharedElements</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setEnterSharedElementCallback(object : SharedElementCallback() &#123;</span><br><span class="line">    override fun <span class="title function_">onMapSharedElements</span><span class="params">(</span></span><br><span class="line"><span class="params">        names: MutableList&lt;String&gt;?,</span></span><br><span class="line"><span class="params">        sharedElements: MutableMap&lt;String, View&gt;?</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMapSharedElements(names, sharedElements)</span><br><span class="line">        <span class="comment">// 将Button加入SharedViews，避免被遮盖</span></span><br><span class="line">        sharedElements?.put(<span class="string">&quot;button&quot;</span>, button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就可以达到将Button加入到SharedElement中去的目的了，viewsReady中随后会调用<code>moveSharedElementsToOverlay()</code>将SharedView显示到ViewOverlay中去。</p>
<h3 id="Button会参与共享元素动画吗"><a href="#Button会参与共享元素动画吗" class="headerlink" title="Button会参与共享元素动画吗"></a>Button会参与共享元素动画吗</h3><p>结论是不会，它只会在共享元素动画结束后和其余View一样通过调用<code>moveSharedElementsFromOverlay()</code>返回到正常布局中去。通过之前的分析可以知道是通过setSharedElementState方法将View设置为初始状态的，在该方法中首先通过transitinName从Activity A传递过来的bundle中获取参数，如果获取不到就直接return。Button是我们强行加入的，Activity A传递的bundle中自然没有，所以Button不会做任何改变，效果如下</p>
<!-- <center><img src="/images/shared5.gif" width="200px" /></center> -->
<p><img src="/images/shared5.gif"></p>
<h2 id="返回动画的流程"><a href="#返回动画的流程" class="headerlink" title="返回动画的流程"></a>返回动画的流程</h2><p>返回和进入的核心流程很相似，但是更加简单。首先我们需要调用<code>Activity#finishAfterTransition()</code>方法来触发返回的动画，其内部调用了<code>ActivityTransitionState#startExitBackTransition()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startExitBackTransition</span><span class="params">(<span class="keyword">final</span> Activity activity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEnteringNames == <span class="literal">null</span> || mCalledExitCoordinator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHasExited) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mReturnExitCoordinator = <span class="keyword">new</span> <span class="title class_">ExitTransitionCoordinator</span>(activity,</span><br><span class="line">                    activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames,</span><br><span class="line">                    <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (delayExitBack &amp;&amp; decor != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">finalDecor</span> <span class="operator">=</span> decor;</span><br><span class="line">                OneShotPreDrawListener.add(decor, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mReturnExitCoordinator != <span class="literal">null</span>) &#123;</span><br><span class="line">                        mReturnExitCoordinator.startExit(activity.mResultCode,</span><br><span class="line">                                activity.mResultData);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部给Activity B创建一个ExitTransitionCoordinator，调用<code>startExit</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startExit</span><span class="params">(<span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mIsExitStarted) &#123;</span><br><span class="line">        mIsExitStarted = <span class="literal">true</span>;</span><br><span class="line">        pauseInput();</span><br><span class="line">        ...</span><br><span class="line">        moveSharedElementsToOverlay();</span><br><span class="line">        <span class="keyword">if</span> (decorView != <span class="literal">null</span> &amp;&amp; decorView.getBackground() == <span class="literal">null</span>) &#123;</span><br><span class="line">            getWindow().setBackgroundDrawable(<span class="keyword">new</span> <span class="title class_">ColorDrawable</span>(Color.TRANSPARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">targetsM</span> <span class="operator">=</span> decorView == <span class="literal">null</span> || decorView.getContext()</span><br><span class="line">                .getApplicationInfo().targetSdkVersion &gt;= VERSION_CODES.M;</span><br><span class="line">        ArrayList&lt;String&gt; sharedElementNames = targetsM ? mSharedElementNames :</span><br><span class="line">                mAllSharedElementNames;</span><br><span class="line">        <span class="type">ActivityOptions</span> <span class="variable">options</span> <span class="operator">=</span> ActivityOptions.makeSceneTransitionAnimation(mActivity, <span class="built_in">this</span>,</span><br><span class="line">                sharedElementNames, resultCode, data);</span><br><span class="line">        mActivity.convertToTranslucent(<span class="keyword">new</span> <span class="title class_">Activity</span>.TranslucentConversionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTranslucentConversionComplete</span><span class="params">(<span class="type">boolean</span> drawComplete)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mIsCanceled) &#123;</span><br><span class="line">                    fadeOutBackground();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, options);</span><br><span class="line">        startTransition(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                startExitTransition();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>Activity#convertToTranslucent()</code>触发Activity A <code>restart()</code>接收到options，options是通过<code>ActivityOptions#makeSceneTransitionAnimation</code>方法创建，将this传递，并设置isReturning&#x3D;true。Activity A触发后走的和之前一样的流程到<code>EnterTransitionCoordinator#viewsReady()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">viewsReady</span><span class="params">(ArrayMap&lt;String, View&gt; sharedElements)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.viewsReady(sharedElements);</span><br><span class="line">    mIsReadyForTransition = <span class="literal">true</span>;</span><br><span class="line">    hideViews(mSharedElements);</span><br><span class="line">    <span class="type">Transition</span> <span class="variable">viewsTransition</span> <span class="operator">=</span> getViewsTransition();</span><br><span class="line">    <span class="keyword">if</span> (viewsTransition != <span class="literal">null</span> &amp;&amp; mTransitioningViews != <span class="literal">null</span>) &#123;</span><br><span class="line">        removeExcludedViews(viewsTransition, mTransitioningViews);</span><br><span class="line">        stripOffscreenViews();</span><br><span class="line">        hideViews(mTransitioningViews);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mIsReturning) &#123;</span><br><span class="line">        sendSharedElementDestination();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moveSharedElementsToOverlay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSharedElementsBundle != <span class="literal">null</span>) &#123;</span><br><span class="line">        onTakeSharedElements();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过由于returning为true，触发<code>sendSharedElementDestination</code>方法，将<code>MSG_SHARED_ELEMENT_DESTINATION</code>发送给Activity B的ExitTransitionCoordinator，ExitTransitionCoordinator开始<code>sharedElementExitBack</code>方法开始返回动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExitTransitionCoordinator.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sharedElementExitBack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">decorView</span> <span class="operator">=</span> getDecor();</span><br><span class="line">    <span class="keyword">if</span> (decorView != <span class="literal">null</span>) &#123;</span><br><span class="line">        decorView.suppressLayout(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decorView != <span class="literal">null</span> &amp;&amp; mExitSharedElementBundle != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !mExitSharedElementBundle.isEmpty() &amp;&amp;</span><br><span class="line">            !mSharedElements.isEmpty() &amp;&amp; getSharedElementTransition() != <span class="literal">null</span>) &#123;</span><br><span class="line">        startTransition(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                startSharedElementExit(decorView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sharedElementTransitionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSharedElementExit</span><span class="params">(<span class="keyword">final</span> ViewGroup decorView)</span> &#123;</span><br><span class="line">    <span class="type">Transition</span> <span class="variable">transition</span> <span class="operator">=</span> getSharedElementExitTransition();</span><br><span class="line">    transition.addListener(<span class="keyword">new</span> <span class="title class_">TransitionListenerAdapter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTransitionEnd</span><span class="params">(Transition transition)</span> &#123;</span><br><span class="line">            transition.removeListener(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (isViewsTransitionComplete()) &#123;</span><br><span class="line">                delayCancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; sharedElementSnapshots = createSnapshots(mExitSharedElementBundle,</span><br><span class="line">            mSharedElementNames);</span><br><span class="line">    OneShotPreDrawListener.add(decorView, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// preDraw的时候将View设置为Activity A的状态，来触发动画</span></span><br><span class="line">        setSharedElementState(mExitSharedElementBundle, sharedElementSnapshots);</span><br><span class="line">    &#125;);</span><br><span class="line">    setGhostVisibility(View.INVISIBLE);</span><br><span class="line">    scheduleGhostVisibilityChange(View.INVISIBLE);</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mListener.onSharedElementEnd(mSharedElementNames, mSharedElements,</span><br><span class="line">                sharedElementSnapshots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始动画</span></span><br><span class="line">    TransitionManager.beginDelayedTransition(decorView, transition);</span><br><span class="line">    scheduleGhostVisibilityChange(View.VISIBLE);</span><br><span class="line">    setGhostVisibility(View.VISIBLE);</span><br><span class="line">    decorView.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文大致介绍了共享元素动画的流程，且着重解析了底层实现的细节，如果大家想深挖动画流程建议阅读源码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/liuyingcan/article/details/50673317">Android中ResultReceiver使用</a><br><a href="https://www.jianshu.com/p/fa1c8deeaa57">Android高阶转场动画-ShareElement完全攻略</a><br><a href="http://www.gcssloop.com/customview/Matrix_Basic">安卓自定义View进阶-Matrix原理</a><br><a href="http://www.gcssloop.com/customview/Matrix_Method">安卓自定义View进阶-Matrix详解</a><br><a href="https://blog.csdn.net/weixin_38020796/article/details/64922899">GhostView</a><br><a href="https://blog.csdn.net/antimage08/article/details/50405391">ViewOverlay 的使用</a></p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS握手协议</title>
    <url>/2019/11/22/HTTPS%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在介绍HTTPS握手协议之前，我们首先介绍一些密码学相关的知识，这样才可以更好的了解HTTPS握手协议<br><img src="/images/https1.png"></p>
<h1 id="密码体制分类"><a href="#密码体制分类" class="headerlink" title="密码体制分类"></a>密码体制分类</h1><p>密码体制从原理上可以分为单钥体制和双钥体制</p>
<h2 id="单钥体制"><a href="#单钥体制" class="headerlink" title="单钥体制"></a>单钥体制</h2><p>单钥体制使用一把密钥进行加密和解密（也叫对称加密），系统的保密性取决于密钥的安全性，与算法的保密性无关。优点是加密计算量小、速度块，适合对大量数据进行加密的场景，常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES。<br>对称加密的使用过程：</p>
<ol>
<li>A使用密钥加密明文发送给B</li>
<li>B使用同一把密钥对密文解密，得到明文</li>
</ol>
<h2 id="双钥体制"><a href="#双钥体制" class="headerlink" title="双钥体制"></a>双钥体制</h2><p>双钥体制分别使用公钥和私钥进行加密解密操作，其中公钥可以公布，私钥是保密的，因此又称为公钥体制（非对称加密）。<br>公钥密码体制以前的整个密码学史中，所有的密码算法都是基于代换和置换这两个工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础，一方面，公钥密码算法和基本工具不是代换和置换，而是数学函数；另一方面，公钥密码算法以非对称的形式使用两个密钥，对保密性、密钥分配、认证都有着深刻的意义。<br>非对称加密的过程：</p>
<ul>
<li>A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。</li>
<li>A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。</li>
<li>A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。</li>
<li>A将这个消息发给B。</li>
<li>B收到这个消息后，用自己的私钥解密，其他所有收到这个消息的人都无法解密，因为只有B才有私钥。</li>
<li>反过来，B向A发送消息也是一样。<br>常见的非对称加密算法有：RSA、Elgamal、ECC等。<br><img src="/images/https2.png"></li>
</ul>
<h1 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h1><p>由于公钥加密速度很慢，不适合进行保密通信，通常使用对称加密算法进行保密通信，那么双方如何就密钥达成共识便成了一个问题，密钥交换算法就应运而生。</p>
<h2 id="采用非对称加密交换密钥"><a href="#采用非对称加密交换密钥" class="headerlink" title="采用非对称加密交换密钥"></a>采用非对称加密交换密钥</h2><p>虽然非对称较密不适合保密通信，但是可以用于交换密钥，一次交换过程如下</p>
<ol>
<li>A生成对称加密密钥key，并用B的公钥加密，将密文发送给B</li>
<li>B收到密文后使用自己的私钥解密得到密钥key</li>
<li>双方采用key进行加密通信</li>
</ol>
<p>使用这种方式交换密钥时，即使攻击者拿到了密文也无法破解出密钥key，因为只有B的私钥可以解密</p>
<h2 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h2><p>交换过程如下</p>
<ol>
<li>Alice和Bob确定一个素数p以及该素数p的本原根a</li>
<li>Alice选择随机数A计算 Ka &#x3D; a ^A mod p</li>
<li>Bob选择随机数B计算 Kb &#x3D; a ^ B mod p</li>
<li>双方交换计算结果Ka、Kb</li>
<li>A计算K &#x3D; Kb ^ A mod p</li>
<li>B计算K &#x3D; Ka ^ B mod p</li>
</ol>
<p>这样双方就共享同一个K了，而攻击者只能拿到p、a、Ka、Kb，想要得到K则必须得到A、B中的一个，这意味着需要求离散对数，因此破解K是不可行的。<br><img src="/images/https3.png"></p>
<h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><p>MAC为消息认证码，指消息被一个密钥控制的公开函数作用后产生的用作认证符的、固定长度的数值，也称密码校验和，用于验证消息的完整性。<br>假设通信双方AB共享同一把密钥K和公开函数C，那么</p>
<ol>
<li>A发送消息M的时候计算MAC &#x3D; C(K, M)，将M || MAC发送给B</li>
<li>B收到后采用相同方式计算MAC，如果不一致则认为M被篡改过</li>
</ol>
<p>由于攻击者没有密钥K，所以在篡改M后无法生成对应的MAC，B就可以依此判断是否被篡改<br><img src="/images/https4.png"></p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>MAC只能保护通信双方被第三方攻击，却不能防止通信双方中的一方被另一方欺骗&#x2F;伪造，比如</p>
<ul>
<li>B使用和A共享的K伪造消息M生成MAC，随后声称这个消息来自于A</li>
<li>由于B也持有K，A在发送消息M后可以否认是自己发送</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>数字签名技术可以解决这个问题，数字签名具有以下性质</p>
<ol>
<li>能够验签名生产者的身份</li>
<li>能用于证实被签消息的内容</li>
<li>可由第三方验证，从而解决通信双方的争议</li>
</ol>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>可以采用非对称加密进行数字签名</p>
<ol>
<li>首先A使用Hash函数获得信息M的信息摘要D</li>
<li>A使用私钥加密D得到Signature，将M || Signature发送给B</li>
<li>B收到后使用A的公钥解密Signature得到信息摘要D，同时自己计算M的信息摘要D’，如果D‘和D一致，则证明信息M就是A发送的</li>
</ol>
<p>因为只有A拥有私钥可以对M加密，所以可以确定该消息为A发送。之所以针对信息摘要D进行签名而不是M是因为M的签名长度和M是一个量级的，这样会增加传输的负载。<br><img src="/images/https5.png"></p>
<h1 id="证书颁发机构-CA"><a href="#证书颁发机构-CA" class="headerlink" title="证书颁发机构(CA)"></a>证书颁发机构(CA)</h1><p>运用对称加密、密钥交换、MAC验证、数字签名技术来对通信链路进行安全性保护表面上已经很安全了，既能够加密信息，还保证了信息的完整性和可靠性。但是无论采用何种密钥交换协议进行密钥交换，在密钥交换完成前通信链路均不可信，那么攻击者可以接管通信链路，对密钥交换过程做手脚，与双方各进行一次密钥交换，最终接管通信。<br>想要解决这个问题，就需要解决信任问题，关键在于A如何信任获得的PubKB来自于B，CA可以解决这个问题。<br>CA即证书颁发机构（Certificate Authority），负责发放和管理数字证书的权威机构。CA的工作如下</p>
<ol>
<li>服务器 example.com将从CA请求TLS证书，例如Digicert。</li>
<li>Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称，服务器的公钥等。</li>
<li>Digicert创建证书的哈希值，并使用自己的私钥对其进行加密。</li>
<li>客户端(浏览器和操作系统)自带Digicert等权威机构的公钥。</li>
<li>客户端收到该签名证书时，它将使用Digicert公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列，如果两个哈希值匹配，则签名验证成功并且证书是可信的。</li>
<li>现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。<br><img src="/images/https6.png"><br><img src="/images/https7.png"></li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们都知道HTTP请求是明文传输的，存在通信内容被窃听、篡改、无法验证通信对象身份等问题，HTTPS是在HTTP的基础上发展而来，意为HTTP Secure，它就是为了解决HTTP协议安全性不足的问题而诞生的。<br>HTTPS实际上是在HTTP和TCP之间加入了一层TLS&#x2F;SSL。</p>
<blockquote>
<p>TLS（Transport Layer Security，传输层安全性协议）以及其前身SSL（Secure Sockets Layer，安全套接层）是一种安全协议，为其上层协议提供在不安全信道上的安全传输服务。</p>
</blockquote>
<p>在HTTPS中，对发送者而言TLS&#x2F;SSL用于加密来自HTTP协议的数据，对接收者而言TLS&#x2F;SSL用于解密来自TCP协议的数据，这样就可以保证数据的安全性。由于客户端&#x2F;服务端均存在加解密的操作，所以双方需要对加密算法&#x2F;密钥等信息达成共识，这一过程也就是TLS握手协议所要达成的目的。<br><img src="/images/https8.png"></p>
<h1 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h1><p>客户端与服务端连接的时候会进行一次TLS握手过程，就加密算法&#x2F;密钥等信息达成共识，接下来详细介绍该过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client                                        Server</span><br><span class="line">------                                        -----</span><br><span class="line">ClientHello          --------&gt;</span><br><span class="line">                                         ServerHello</span><br><span class="line">                                        Certificate*</span><br><span class="line">                                  ServerKeyExchange*</span><br><span class="line">                     &lt;--------       ServerHelloDone</span><br><span class="line">ClientKeyExchange</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished             --------&gt;</span><br><span class="line">                                  [ChangeCipherSpec]</span><br><span class="line">                     &lt;--------              Finished</span><br><span class="line"></span><br><span class="line">Application Data     &lt;-------&gt;      Application Data</span><br></pre></td></tr></table></figure>
<h2 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h2><p>第一步为客户端发送hello报文，通过wireshark我们可以看到内容如下<br><img src="/images/https9.png"><br>ClientHello报文传递给服务端如下信息</p>
<ol>
<li><p>Version: 客户端支持的TLS协议版本</p>
</li>
<li><p>Random: 客户生成的随机数，该随机数会在后面的过程中用到。</p>
</li>
<li><p>Cipher Suites：客户端支持的密码套件，由客户按优先顺序排列，提供给服务端来选择，这里取其中一个来介绍密码套件的组成格式</p>
<blockquote>
<p>Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)<br> TLS: 使用TLS协议<br> ECDHE: 密钥交换算法<br> ECDSA: 签名或验证算法<br> AES_128_GCM: 加解密算法<br> SHA256: 消息验证算法(MAC)</p>
</blockquote>
</li>
<li><p>Compression Methods: 客户端支持的压缩算法，由于使用压缩可能导致安全问题，从TLS 1.3开始，协议就禁用了TLS压缩。</p>
</li>
<li><p>Extension：随后就是一系列的扩展参数了，用于扩展功能</p>
</li>
</ol>
<h2 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h2><p>服务端接收到客户端hello报文后，会根据报文内容发送服务端hello报文给客户端<br><img src="/images/https10.png"><br>服务器会检查客户端支持的TLS版本和密码套件等信息，如果服务端接受这些条件，则回复服务端所选择的密码套件等信息给客户端，反之则发送握手失败信息。</p>
<ol>
<li>Version：服务端支持的TLS版本</li>
<li>Random：服务端生成的随机数，与客户端的随机数在后面过程会被使用</li>
<li>Cipher Suite：服务端选择的密码套件，后续HTTPS握手&#x2F;通信均使用该密码套件</li>
</ol>
<h2 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h2><p>接下来服务端将会把证书发送给客户端<br><img src="/images/https11.png"><br>证书包含以下信息</p>
<ol>
<li>signature：签名算法</li>
<li>encrypted：该证书的签名</li>
<li>issuuer：该证书的颁布机构，用于配合签名检验该证书的合法</li>
<li>validity：证书的有效期</li>
<li>subject：持有该证书组织的信息</li>
<li>subjectPublicKeyInfo：带公钥和用于生成公钥的算法。此密钥用于交换密钥，我们将在稍后讨论。</li>
</ol>
<h2 id="ServerKeyExchange"><a href="#ServerKeyExchange" class="headerlink" title="ServerKeyExchange"></a>ServerKeyExchange</h2><p>紧接着服务端发送ServerKeyExchange报文与客户端进行密钥交换流程，仅当服务端的证书不足以完成和客户端交换预主密钥(后面会介绍)的情况下才会发送，比如Diffie-Hellman算法需要通信双方协作才能进行密钥交换。需要发送ServerKeyExchange的交换算法包括以下几种</p>
<blockquote>
<p>ECDH_ECDSA<br>ECDHE_ECDSA<br>ECDH_RSA<br>ECDHE_RSA<br>ECDH_anon </p>
</blockquote>
<p><img src="/images/https12.png"><br>从之前的ServerHello报文可以看出服务端选择了ECDHE算法来做密钥交换，RSA做签名校验。所以Server Key Exchange报文就包含了ECDHE交换服务端需要提供的相关参数，其中这些参数通过RSA签名，客户端收到后通过服务端证书上的公钥来进行签名验证，防止中间人攻击。</p>
<h2 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h2><p>服务端昨晚上述操作后就会发送ServerHelloDone报文告知服务端已经发送完毕。<br><img src="/images/https13.png"></p>
<h2 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h2><p>ClientKeyExchange和ServerKeyExchange不同，并不是可选步骤，而是必要步骤，这一步将生成预主密钥并与服务端就预主密钥达到共识，即双方得到共同的预主密钥。<br>如果采用Diffie-Hellman算法进行交换，则还需要客户端提供相应参数给服务端，双方各自计算出预主密钥(由Diffie-Hellman算法保证双方得到的密钥是一致的)。如果是RSA交换则并不需要ServerKeyExchange，只需要客户端自己随机生成预主密钥，使用服务端的公钥加密传递给服务端即可。</p>
<h2 id="生成主密钥"><a href="#生成主密钥" class="headerlink" title="生成主密钥"></a>生成主密钥</h2><p>到目前为止双方共享三个值</p>
<ol>
<li>客户端随机数ClientHello.random，公开信息</li>
<li>服务端随机数ServerHello.random，公开信息</li>
<li>预主密钥pre_master_secret，保密信息</li>
</ol>
<p>计算主密钥的方式由RFC 5356规定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_secret = PRF（pre_master_secret，“master secret”，ClientHello.random + ServerHello.random）[0..47];</span><br></pre></td></tr></table></figure>
<p>其中，<code>PRF</code>是协议约定的伪随机函数。<br>得到主密钥后也不能开始加解密操作，而是需要根据主密钥生成四把密钥，两把用来加解密，两把用来生成MAC（因为部分对称加密算使用相同的密钥加密并不安全）。</p>
<ul>
<li>客户端写入加密密钥：客户端用来加密数据，服务器用来解密数据。</li>
<li>服务器写入加密密钥：服务器用来加密数据，客户端用来解密数据。</li>
<li>客户端写入MAC密钥：客户端用来创建MAC，服务器用来验证MAC。</li>
<li>服务器写入MAC密钥：服务器用来创建MAC，客户端用来验证MAC。</li>
</ul>
<p>由于以上步骤可以保证明文不会被破解，但是没法保证不会被篡改，所以在通信的时候会针对明文生成MAC与密文一起发送，接收方解密出明文后计算出MAC进行比对，以保证通信内容没有被篡改。</p>
<h2 id="测试密钥"><a href="#测试密钥" class="headerlink" title="测试密钥"></a>测试密钥</h2><p>双方就密钥达成共识后将会进行一次测试阶段，客户端将测试文本使用客户端密钥加密，发送给服务端，服务端解密后使用自己的密钥加密后再发回给客户端，客户端使用服务端密钥解密后对比文本是否一致，如果一致则测试通过。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>HTTPS相比HTTP增加的耗时主要为两个点</p>
<ol>
<li>TLS握手协议增加的耗时</li>
<li>加解密数据的耗时</li>
</ol>
<h3 id="SessionId"><a href="#SessionId" class="headerlink" title="SessionId"></a>SessionId</h3><p>在实际请求中，并不是每次都需要进行TLS握手的。如果之前已经完成过一次TLS握手协议，服务端会生成一个sessionId发送给客户端，客户端将该sessionId和当前的通信密钥信息保存起来。下次客户端连接同一个服务端的时候将会带上sessionId，由于双方都保存有该sessionId对应的密钥信息，所以就无须进行后续握手流程，直接使用sessionId对应的密钥信息进行通信。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>以上方案会导致服务端需要很大的空间去存储sessionId和对应的密钥信息，所以产生了SessionTicket方案。服务端将密钥信息加密后生成一个SessionTicket发送给客户端，客户端进行保存，在后续的连接中客户端在ClientHello中带上SessionTicket，服务端解密验证后直接采用对应的密钥信息进行通信。</p>
<h1 id="Charles代理原理"><a href="#Charles代理原理" class="headerlink" title="Charles代理原理"></a>Charles代理原理</h1><p>通过上述分析的TLS握手过程，我们可以知道HTTPS可以有效防止中间人攻击。但是用过Charles的人都知道，我们可以抓取HTTPS的通信明文且进行更改，那么Charles是如何做到的呢？<br>HTTPS的安全性本质上基于证书的可靠性，默认情况下客户端内置可信的CA信息，但是如果用户手动将不可信的CA加入信任列表，那么就无法保证安全性了，Charles就是这样做的。在使用Charles抓包的时候，我们需要安装Charles提供的证书并加入信任列表，这样Charles就可以针对端上的HTTPS请求发起中间人攻击，示意图如下所示<br><img src="/images/https14.png"><br>由于Charles的证书已经在信任名单，所以客户端在校验伪造证书的时候会使用Charles的CA证书提供的公钥进行签名验证，验证通过后继续后续连接流程。通过浏览器查看证书也可以证实这一点<br><img src="/images/https15.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tools.ietf.org/html/rfc4492#page-4">RFC4492</a></li>
<li><a href="https://xz.aliyun.com/t/2530">SSL&#x2F;TLS协议详解(中)——证书颁发机构</a></li>
<li><a href="https://xz.aliyun.com/t/2531#toc-16">SSL&#x2F;TLS协议详解(下)——TLS握手协议</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>Handler详解--实战篇</title>
    <url>/2016/11/15/Handler%E8%AF%A6%E8%A7%A3-%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前写了一篇文章讲解Handler机制，但是我觉得理论总是不比实践来的深刻，所以今天我们来自己实现一个Handler。如果没看过之前的文章，建议先看一下<a href="http://blog.csdn.net/a62321780/article/details/53173688">Android Handler详解–理论篇</a>。</p>
<h1 id="MyMessageQueue"><a href="#MyMessageQueue" class="headerlink" title="MyMessageQueue"></a>MyMessageQueue</h1><p>首先实现MyMessageQueue，当然在这之前我们要实现MyMeessage类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyHandler target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便，我只写了一个Handler成员变量<br>接下来就是MyMessageQueue的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;MyMessage&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyMessageQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MyMessage message)</span> &#123;</span><br><span class="line">        queue.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出队头的消息并出队,队列位空的时候阻塞</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> MyMessage <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MyMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyMessageQueue.<span class="built_in">this</span>) &#123;</span><br><span class="line">            message = queue.get(<span class="number">0</span>);</span><br><span class="line">            queue.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，有两个方法，入队和出队，对列为空的时候出队方法next()会被阻塞直到有新的消息进来。</p>
<h1 id="MyLooper"><a href="#MyLooper" class="headerlink" title="MyLooper"></a>MyLooper</h1><p>MyLooper的实现依赖ThreadLocal，我们提供prepare()、getLooper()、loop()三个静态方法，在内部维护一个静态的ThreadLocal&lt; MyLooper &gt;变量，通过这个变量设置或获取当前线程的Looper实例。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLooper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyLooper&gt; sLooper = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyMessageQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">MyMessageQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sLooper.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            sLooper.set(<span class="keyword">new</span> <span class="title class_">MyLooper</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyLooper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sLooper.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sLooper.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;no looper exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">MyMessage</span> <span class="variable">myMessage</span> <span class="operator">=</span> sLooper.get().queue.next();</span><br><span class="line">            <span class="comment">//Log.d(&quot;Debug&quot;, myMessage.toString());</span></span><br><span class="line">            myMessage.target.handleMessage(myMessage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Looper内部维护一个MessageQueue变量，在loop()方法中无限循环查询queue，有消息就调用Message.target.handleMessage()。但是我们这里在取出一条消息处理之后就跳出循环了，这是为什么呢？不要着急，下面会详细解释，虽然只取一条，但是也足够展示在子线程更新UI的效果了。</p>
<h1 id="MyHandler"><a href="#MyHandler" class="headerlink" title="MyHandler"></a>MyHandler</h1><p>MyHandler持有当前线程的Looper，在创建的时候根据当前线程获得，如果当前线程没有Looper则报错。在sendMessage方法中将Message的target赋值，然后入队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyLooper looper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyMessageQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        looper = MyLooper.getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;current thread does not have looper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue = looper.queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(MyMessage message)</span> &#123;</span><br><span class="line">        message.target = MyHandler.<span class="built_in">this</span>;</span><br><span class="line">        queue.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(MyMessage message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>好了，现在我们在布局文件中放一个TextView显示Hello,World</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/activity_main&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MainActivity代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        textView = (TextView) findViewById(R.id.text);</span><br><span class="line"></span><br><span class="line">        MyLooper.prepare();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">MyHandler</span> <span class="variable">myHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(MyMessage message)</span> &#123;</span><br><span class="line">                textView.setText(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                myHandler.sendMessage(<span class="keyword">new</span> <span class="title class_">MyMessage</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        MyLooper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下<br><img src="/images/handler.jpeg" alt="这里写图片描述"></p>
<h1 id="疑点解惑"><a href="#疑点解惑" class="headerlink" title="疑点解惑"></a>疑点解惑</h1><p>虽然我们完成了子线程更新UI，但是还是有一些问题的，假设我们将Looper的loop方法设为无限循环，而不是取到一条消息就退出循环，那会怎么样？其实都不用试，想一下就知道那主线程就被阻塞了，无法响应用户操作，然后报ANR错误。这样另一个问题就出来了，那为什么主线程原本的Looper不会阻塞呢？他的源码里也是无限循环啊？接下来根据源码来说明一下这个问题。<br>大家都知道java程序有一个入口点public static void main(String[] args)，那既然Android是用java写的，大家一直就不疑惑入口点在哪吗？其实android程序的入口点在ActivityThread这个类当中，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> <span class="title class_">EventLoggingReporter</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在代码的最后开启了loop，这里就无限循环了，假设一下，如果没有无限循环，那么main方法就结束了，那程序不就结束了么。。。。<br>Android是基于事件驱动的，也就是说我们的整个应用就是运行在这个最大的Looper循环中的，比如现在系统有一个Activity，在某一情况下需要调用他的onPause方法，怎么办？系统会通过本身的Handler发送一个消息，然后这个Looper获取然后处理（也就是调用Activity的onPause回调方法）。再比如现在啥都不干，那系统就阻塞着，也不会ANR，直到我们有什么动作（比如有触摸事件产生），那么Looper就继续处理。<br>那ANR在什么情况下会发生？ANR只会在handler处理一条消息超过一定时间才会发生，而不是阻塞就会发生（系统基于事件驱动，说明有事件才会动，没事件就阻塞）。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Handler详解--理论篇</title>
    <url>/2016/11/15/Handler%E8%AF%A6%E8%A7%A3-%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在平时的开发中，我们一般会在子线程请求数据，因为Android的UI操作不是线程安全的，所以我们会有切换到UI线程(主线程)更新UI的需求。有以下两种方法：</p>
<ul>
<li>使用Activity的runOnUiThread方法。</li>
<li>使用Handler。</li>
</ul>
<p>其实查看源码就能发现runOnUIThread方法还是基于Handler的，接下来就详细解析Handler机制。</p>
<h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><p>Handler机制其实是Handler、MessageQueue、Looper三个类共同作用的结果，只是我们经常和Handler打交道所以对Handler比较熟悉。</p>
<h1 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h1><p>这个类相对简单，维护一系列的Message，有两个主要方法</p>
<ul>
<li>boolean enqueueMessage(Message msg, long when)</li>
<li>Message next()</li>
</ul>
<p>enqueueMessage将一条消息入队，next方法返回队头的一条消息，并将该条消息出队，需要注意的是如果消息队列为空，那么这个方法就会阻塞直到有消息入队。</p>
<h1 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h1><p>每个线程都有自己的Looper实例，通过Looper.myLooper()获得当前线程的Looper实例，这是通过ThreadLocal实现的，如果不知道ThreadLocal的<a href="http://blog.csdn.net/lufeng20/article/details/24314381">点这</a>。<br>Looper的作用就是无限循环从MessageQueue中拿消息，拿到消息之后调用方法（后面会讲到）。</p>
<p>先看看Looper类的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br></pre></td></tr></table></figure>

<p>除了主线程默认有Looper外，其余的线程若想使用必须调用Looper.prepare()初始化当前线程Looper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看Looper的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出一个Looper持有一个自己的MessageQueue，而且一个线程只会有一个Looper，也就是一个线程一个MessageQueue。</p>
<p>接下来就是最重要的方法了–Loop.loop()，先看看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出是在一个死循环中从队列取出消息，然后调用msg.target.dispatchMessage(msg)处理消息。其实仔细看会发现如果返回null，那么就会跳出死循环，那么什么时候queue.next()会返回null呢？当Looper的quit被调用的时候，他就会调用queue的quit，这样queue就会返回null，从而达到退出loop的目的。</p>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>Handler作用就是发送消息和处理消息，当一个Handler创建的时候，他就会和当前线程的Looper关联起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中得到当前线程的Looper和MessageQueue，并保存起来。重头戏在sendMessageAtTime方法，其他方法发送信息最后都是使用这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这里就将消息放入队列了，然后Looper一直在循环消息队列，这个时候他就拿到一条消息，然后调用msg.target.dispatchMessage(msg)处理消息，我们看一下Message的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User-defined message code so that the recipient can identify </span></span><br><span class="line"><span class="comment">     * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment">     * for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment">     * with other handlers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> what;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">     * few integer values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> arg1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">     * few integer values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> arg2;</span><br><span class="line">    <span class="comment">/*package*/</span> </span><br><span class="line">    Handler target;</span><br></pre></td></tr></table></figure>
<p>可以看出每一条消息都有一个target变量，代表发送他的Handler，而且以后处理消息也是这个Handler，那这个target是在哪里赋值的呢？其实是在sendMessageAtTime中的enqueueMessage()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="梳理流程"><a href="#梳理流程" class="headerlink" title="梳理流程"></a>梳理流程</h1><p>每个类的原理都讲明白了，接下来我们整理一下他们的关系。一个线程只有一个Looper，一个Looper内部维护着一个MessageQueue，创建Handler的时候，该Handler自动和当前线程的Looper关联起来。<br>当使用该Handler发送消息的时候，使用Handler关联Looper的MessageQueue将消息入队，然后Looper无限循环查询消息队列，一有消息就处理，处理方式是通过调用该Message的target的handleMeessage方法。</p>
<h1 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h1><p>大概流程就是这样，但是可能有人还是很迷糊，那到底是怎么样实现线程的切换的？<br>我们一步一步来看，如果我们的Handler在主线程创建，那么关联的就是主线程的Looper，到最后调用的handleMessage的就是这个Looper，那么该方法就肯定在主线程运行了。而在子线程中，我们做的只不过是发送消息，也就是改变主线程的消息队列，然后主线程的Looper拿到消息处理，这样就实现了线程转换。</p>
<p>下一篇我们会自己实现一个Handler加深对Handler机制对理解，而且还涉及到Android程序启动的流程，有兴趣的朋友可以看一眼。</p>
<a href="/2016/11/15/Handler%E8%AF%A6%E8%A7%A3-%E5%AE%9E%E6%88%98%E7%AF%87/" title="Handler详解--实战篇">Handler详解--实战篇</a>

]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Java匿名内部类使用局部变量</title>
    <url>/2017/03/04/Java%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>在Java8之前，我们在匿名内部类或者局部内部类中使用局部变量都需要将局部变量声明为final，这是因为java底层给我们做了一些小动作，匿名内部类表面上没有构造函数，其实是有的，底层直接将局部变量通过构造函数传给内部类，局部变量在生命周期结束后就会被销毁，而匿名内部类的生命周期一般来说都比局部变量长，那么假如我们可以修改这个变量，就会出现内外不一致的现象（这里的修改指的是改变引用，而不是改变变量的内容），因为外面的局部变量是不会因为内部的引用改变而改变的，所以强制要求声明为final。<br>但是在Java8中，出现了Effectively final，意思就是，假如这个局部变量我们在使用过程中都不会出现改变引用的情况，那么我们不需要加final，默认是final，如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		        </span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			node.a = <span class="number">2</span>;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java8编译中编译是不会出错的，然后我们修改一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		        </span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			node = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候就会报错，因为我们尝试修改node的值（引用），所以就不是有效final了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java线程池简析</title>
    <url>/2016/08/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<h1 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h1><p>我们在实现并发功能时会频繁的创建和销毁线程，这样会加大系统的开销，而线程池会缓存一定数量的线程，可以避免这样的情况，并且线程池可以对现场进行简单的管理，简化了并发编程。</p>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>Java中的线程池定义为Executor接口，实现这个接口的类为ThreadPoolExecutor，是线程池的真正实现。常用的构造方法为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：线程池中的核心线程数量，核心线程理论上会一直存活，就算是闲置状态。</li>
<li>maximumPoolSize：允许线程池最大容纳的线程数，一旦满了，后面新到来的任务会被阻塞。</li>
<li>keepAliveTime：线程闲置的超时时长，闲置时间超过就会被销毁，适用于非核心线程。如果ThredPoolExecutor的allowCoreThreadTimeOut设置为true，那么核心线程也会超时销毁。</li>
<li>unit：超时时长的单位，为枚举类型，常用的有毫秒 TimeUnit.MILLISECONDS、秒TimeUnit.SECONDS、分TimeUnit.MINUTES。</li>
<li>workQueue：任务队列。</li>
<li>threadFactory：提供创建线程的功能。</li>
</ul>
<p>当任务到来的时候，如果核心线程数量没有达到最大核心线程数量，那么就创建核心线程执行任务。如果超过就将任务插入队列等待核心线程空下来。如果队列也满了，那就只有创建非核心线程（或者复用闲置非核心线程）执行任务。如果全部线程数达到最大值，拒绝执行任务。</p>
<h1 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h1><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心线程和线程数一样说明只有核心线程，那么线程都不会被回收，可以很快的响应任务。</li>
<li>且队列没有没有大小限制，可以看出新到来的任务肯定不会被拒绝，因为队列不会满，所有任务都可以被执行（核心线程满了就等待）。</li>
</ul>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有核心线程，且线程数是int的最大值，适用于大量的任务。</li>
<li>SynchronousQueue实际上是不能插入的，所以任务到来的时候，首先没有核心线程，那么就会插入队列等待核心线程，但是这个队列不能插入，所以开启非核心线程执行，也就是说任务到来立马执行，适用于大量且耗时少的任务。</li>
</ul>
<h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就一个核心线程，线程只允许一个，等待队列没限制，也就是说任务是串行执行的，不用考虑同步的问题。</p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="执行Runnable"><a href="#执行Runnable" class="headerlink" title="执行Runnable"></a>执行Runnable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">exe</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != <span class="number">5</span>; i++) &#123;</span><br><span class="line">			exe.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		exe.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// do something here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过execute执行任务，shutdown()方法可以防止新任务被提交给这个Executor，执行完之前的所有任务后会尽快退出。</p>
<h4 id="执行Callable"><a href="#执行Callable" class="headerlink" title="执行Callable"></a>执行Callable</h4><p>Runnable执行任务不返回任何值，想要有返回值的话可以使用Callable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">exe</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">		List&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != <span class="number">5</span>; i++) &#123;</span><br><span class="line">			results.add(exe.submit(<span class="keyword">new</span> <span class="title class_">Task</span>()));</span><br><span class="line">		&#125;</span><br><span class="line">		exe.shutdown();</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(fs.get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i++ + <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先确定返回值的类型，这里是String，执行的方法是call而不是run。使用submit提交任务而不是execute，submit会返回Future<String>的值，然后我们遍历通过get()方法拿到返回值。值得注意的是，当Future未完成的时候，get()方法会阻塞，直到完成拿到返回值，我们可以通过isDone()判断是否完成。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>LeakCanary中的最短路径算法</title>
    <url>/2019/12/11/LeakCanary%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Leakcanary是square公司开源的内存泄露分析工具，所谓square出品必属精品，LeakCanary提供了一整套的内存泄漏监控 &amp; 分析自动化流程。具体的流程如下</p>
<ol>
<li>泄漏对象检测</li>
<li>泄漏达到阈值后dump内存快照</li>
<li>分析内存快照，查找泄漏对象</li>
<li>查找泄漏对象到GCRoot的最短路径，输出泄漏链路</li>
</ol>
<p>本文主要分析泄漏对象到GCRoot的最短路径算法</p>
<h1 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h1><p>通过解析Hprof文件，可以获得堆上所有对象的引用链，我们可以将这些对象以及之间的引用关系看作一张有向无权图，这样就相当于求解有向无权图的最短路径</p>
<h1 id="有向无权图的最短路径"><a href="#有向无权图的最短路径" class="headerlink" title="有向无权图的最短路径"></a>有向无权图的最短路径</h1><p>有向无权图的最短路径可以通过广度优先遍历来实现。</p>
<h1 id="LeakCanary实现"><a href="#LeakCanary实现" class="headerlink" title="LeakCanary实现"></a>LeakCanary实现</h1><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>最短路径不是唯一的，LeakCanary只能找到其中一条，可能导致只能分析出部分泄漏的原因。</p>
]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>MAT中的Shallow Heap和Retained Heap</title>
    <url>/2019/09/24/MAT%E4%B8%AD%E7%9A%84ShallowSize%E5%92%8CRetainedSize/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在使用MAT分析内存快照的时候我们一般会关注对象占用的内存大小，在MAT中我们可以观察到两个数据Shallow Heap和Retained Heap，网上有很多文章介绍这两个数据的概念以及计算方式，但是很多文章都是有问题的(因此走了不少弯路)，所以自己研究了一下，接下来分别介绍。</p>
<p>PS:以下均以32位为例</p>
<h1 id="Shallow-Heap"><a href="#Shallow-Heap" class="headerlink" title="Shallow Heap"></a>Shallow Heap</h1><p>Shallow Heap指的是对象本身占用的内存大小，包含两部分：</p>
<ul>
<li>对象头：可参考<a href="https://blog.csdn.net/lkforce/article/details/81128115">Java的对象头和对象组成详解</a>，总结一下就是普通对象的对象头占8字节，数组对象占12字节(包括4字节的数组长度)</li>
<li>成员变量：如果是基本类型则按照基本类型的大小来算(如int占用4字节，char占用2字节)，如果是对象引用则一律占用4个字节</li>
</ul>
<p>由以上可得出Shallow Heap计算方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shallow Heap = sizeof(对象头) + sizeof(所有成员变量)</span><br></pre></td></tr></table></figure>
<p>由于对象内存分配是以8字节为单位的，所以最终的Shallow Heap如果不是8的倍数则需要增加至8的倍数</p>
<h1 id="Retained-Heap"><a href="#Retained-Heap" class="headerlink" title="Retained Heap"></a>Retained Heap</h1><p>为了能够更好的理解，引入Retained Set 和 Dominator的概念</p>
<ul>
<li>Dominator：如果GCRoot到对象B的所有路径中均包含对象A，则称A为B的Dominator，意味着如果A被回收，GCRoot将没有到B的链路，B成为可回收对象。</li>
<li>Retained Set：对象A的Retained Set指的是包含所有以A为Dominator的对象的集合</li>
</ul>
<p>A的Retained Heap就是A和Retained Set中所有对象的Shallow Heap的合，可以理解为A被回收后进行一次GC，包括A可总共回收的内存就是Retained Heap。</p>
<p>Retained Heap计算方法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Retained Heap = shallowHeapOf(A) + shallowHeapOf(Retained Set内所有对象)</span><br></pre></td></tr></table></figure>

<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>接下来举一个例子来应用上述计算方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    long l = 0;</span><br><span class="line">    int[] intArray = new int[2];</span><br><span class="line">    char[] charArray = new char[2];</span><br><span class="line">    B b = new B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    long l = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	A a = new A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中有一个对象A，A持有对象B，我们首先来计算A、B的Shallow Heap</p>
<h2 id="计算Shallow-Heap"><a href="#计算Shallow-Heap" class="headerlink" title="计算Shallow Heap"></a>计算Shallow Heap</h2><p>A持有两个基本类型的变量i、l和三个对象引用(数组也是对象！)，所以</p>
<blockquote>
<p>Shallow Heap &#x3D; 8(对象头) + 4(int) + 8(long) + 4(对象引用) + 4(对象引用) + 4(对象引用) &#x3D; 32</p>
</blockquote>
<p>B就只有两个基本类型的变量，所以</p>
<blockquote>
<p>Shallow Heap &#x3D; 8(对象头) + 4(int) + 8(long) &#x3D; 20</p>
</blockquote>
<p>但是20不是8的倍数，所以真正的Shallow Heap为24</p>
<h2 id="计算Retained-Heap"><a href="#计算Retained-Heap" class="headerlink" title="计算Retained Heap"></a>计算Retained Heap</h2><p>由于B没有持有任何对象引用，所以Retained Heap就是Shallow Heap，为24<br>A持有三个对象引用，所以</p>
<blockquote>
<p>Retained Heap(A) &#x3D; Shallow Heap(A) + 三个对象的Retained Heap</p>
</blockquote>
<p>intArray不持有对象，只持有基本类型int，所以</p>
<blockquote>
<p>Retained Heap(intArray) &#x3D; Shallow Heap(intArray) &#x3D; 12(对象头) + 4(int) * 2 &#x3D; 20 -&gt; 24</p>
</blockquote>
<p>charArray同样不持有对象，只持有基本类型char，所以</p>
<blockquote>
<p>Retained Heap(charArray) &#x3D; Shallow Heap(charArray) &#x3D; 12(对象头) + 2(char) * 2 &#x3D; 16</p>
</blockquote>
<p>综上</p>
<blockquote>
<p>Retained Heap(A) &#x3D; 32(Shallow Heap) + 24(int[]) + 16(char[]) + 24(b) &#x3D; 96</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/shallowretainedheap.html">Shallow and retained heap</a><br><a href="https://blog.csdn.net/lkforce/article/details/81128115">Java的对象头和对象组成详解</a><br><a href="https://mingjunli.gitbooks.io/mat/content/%E6%A6%82%E5%BF%B5/Immediate%20Dominators.html">Immediate Dominators</a></p>
]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>NestedScrolling详解</title>
    <url>/2017/06/18/NestedScrolling%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>假设我们需要一个这样的效果，拖动子View的时候需要parent先滑动，等parent滑倒顶端的时候再让子View滑动。Android事件分发机制在parent处理事件的时候，没法再次把事件传递给子View（除非再来一个Down，开启一个新的事件序列），所以就需要用到NestedScrolling，也就是嵌套滑动机制。今天我们来实现如下效果<br><img src="/images/nested.gif" alt="这里写图片描述"><br>蓝色部分是子View，粉色是Parent，在向上滑动时，保证Parent首先滑动到顶端，向下滑动时保证子View首先滑倒底部。</p>
<h2 id="基本类和方法"><a href="#基本类和方法" class="headerlink" title="基本类和方法"></a>基本类和方法</h2><p>这里需要用到两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NestedScrollingChild</span><br><span class="line">NestedScrollingParent</span><br></pre></td></tr></table></figure>
<p>和两个辅助类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NestedScrollingChildHelper</span><br><span class="line">NestedScrollingParentHelper</span><br></pre></td></tr></table></figure>

<h4 id="NestedScrollingChild"><a href="#NestedScrollingChild" class="headerlink" title="NestedScrollingChild"></a>NestedScrollingChild</h4><p>子View实现这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNestedScrollingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNestedScrollingEnabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="type">int</span> axes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed, <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedPreFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>void setNestedScrollingEnabled(boolean enabled)：允许嵌套滑动</li>
<li>boolean startNestedScroll(int axes)：一般在ACTION_DOWN的事件里调用，表示要开始滑动，axes代表方向，有SCROLL_AXIS_VERTICAL、SCROLL_AXIS_HORIZONTAL两种</li>
<li>boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)：一般在ACTION_MOVE种调用，dx、dy是将要滑动的量，然后分发给Parent让他消耗，consumed是一个二维数组，分别存储Parent消耗的x、y方向上的量，如果无消耗那么返回false。</li>
</ul>
<h4 id="NestedScrollingParent"><a href="#NestedScrollingParent" class="headerlink" title="NestedScrollingParent"></a>NestedScrollingParent</h4><p>Parent实现这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onStartNestedScroll</span><span class="params">(View child, View target, <span class="type">int</span> nestedScrollAxes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="type">int</span> nestedScrollAxes)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopNestedScroll</span><span class="params">(View target)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScroll</span><span class="params">(View target, <span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(View target, <span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedFling</span><span class="params">(View target, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedPreFling</span><span class="params">(View target, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNestedScrollAxes</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>void onNestedPreScroll(View target, int dx, int dy, int[] consumed)：子View调用dispatchNestedPreScroll的时候此方法会被回调，通过判断dx、dy来计算消耗，返回消耗值。</li>
</ul>
<p>然而真正的逻辑实现都由Helper类帮我们实现了，我们只需要调用helper类的对应方法即可，接下来开始写代码。</p>
<h2 id="ChildView代码"><a href="#ChildView代码" class="headerlink" title="ChildView代码"></a>ChildView代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wulinpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span>: 17/6/17 下午10:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildView</span> <span class="keyword">extends</span> <span class="title class_">View</span> <span class="keyword">implements</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NestedScrollingChildHelper helper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">lastY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] consume = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] offset = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        helper = <span class="keyword">new</span> <span class="title class_">NestedScrollingChildHelper</span>(<span class="built_in">this</span>);</span><br><span class="line">        helper.setNestedScrollingEnabled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                lastY = event.getY();</span><br><span class="line">                <span class="comment">// 开始垂直的滑动</span></span><br><span class="line">                helper.startNestedScroll(SCROLL_AXIS_VERTICAL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 获得滑动量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">dy</span> <span class="operator">=</span> (<span class="type">int</span>) (event.getY() - lastY);</span><br><span class="line">                <span class="keyword">if</span> (dy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 向上滑动的逻辑，保证parent消耗，才到自己</span></span><br><span class="line">                    <span class="keyword">if</span> (!helper.dispatchNestedPreScroll(<span class="number">0</span>, (<span class="type">int</span>) dy, consume, offset)) &#123;</span><br><span class="line">                        <span class="comment">// 运行到这说明parent不消耗了，parent已经到达顶部，这时候自身滑动</span></span><br><span class="line">                        <span class="comment">// 因为向上滑动dy &lt; 0，所以*－1方便比较</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">space</span> <span class="operator">=</span> (<span class="type">int</span>) getY() * -<span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">consumeY</span> <span class="operator">=</span> Math.max(space, dy);</span><br><span class="line">                        setY(getY() + consumeY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 向下滑动的逻辑，保证自己消耗，才到parent</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">space</span> <span class="operator">=</span> (<span class="type">int</span>) (((ParentView) getParent()).getHeight() - getY() - getHeight());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">consumeY</span> <span class="operator">=</span> Math.min(space, dy);</span><br><span class="line">                    dy -= consumeY;</span><br><span class="line">                    setY(getY() + consumeY);</span><br><span class="line">                    <span class="comment">// 自己消耗完后，然后传给Parent剩下的dy－consumeY</span></span><br><span class="line">                    helper.dispatchNestedPreScroll(<span class="number">0</span>, (<span class="type">int</span>) dy, consume, offset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNestedScrollingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        helper.setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNestedScrollingEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.isNestedScrollingEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="type">int</span> axes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        helper.stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="type">int</span>[] offsetInWindow)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> helper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed, <span class="type">int</span>[] offsetInWindow)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> helper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.dispatchNestedFling(velocityX, velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedPreFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.dispatchNestedPreFling(velocityX, velocityY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释比较清楚了，主要就是方向不同逻辑不同，向上的时候先分发给Parent，如果Parent不消耗了（返回false，也就是说到达顶部了），那么自己消耗dy（向上滑动，注意越界情况）；向下的时候，首先自己向下滑动（自己消耗dy），然后给Parent分发消耗后的dy。</p>
<h2 id="ParentView代码"><a href="#ParentView代码" class="headerlink" title="ParentView代码"></a>ParentView代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wulinpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span>: 17/6/17 下午10:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentView</span> <span class="keyword">extends</span> <span class="title class_">FrameLayout</span> <span class="keyword">implements</span> <span class="title class_">NestedScrollingParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NestedScrollingParentHelper helper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParentView</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        helper = <span class="keyword">new</span> <span class="title class_">NestedScrollingParentHelper</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(View target, <span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed)</span> &#123;</span><br><span class="line">        <span class="type">FrameLayout</span> <span class="variable">parent</span> <span class="operator">=</span> (FrameLayout) getParent();</span><br><span class="line">        <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 向下滑动</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">space</span> <span class="operator">=</span> (<span class="type">int</span>) (parent.getHeight() - getY() - getHeight());</span><br><span class="line">            <span class="type">int</span> <span class="variable">consumeY</span> <span class="operator">=</span> Math.min(dy, space);</span><br><span class="line">            consumed[<span class="number">1</span>] = consumeY;</span><br><span class="line">            setY(getY() + consumeY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上滑动</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">space</span> <span class="operator">=</span> (<span class="type">int</span>) (getY() * -<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">consumeY</span> <span class="operator">=</span> Math.max(dy, space);</span><br><span class="line">            consumed[<span class="number">1</span>] = consumeY;</span><br><span class="line">            setY(getY() + consumeY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedFling</span><span class="params">(View target, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedPreFling</span><span class="params">(View target, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNestedScrollAxes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper.getNestedScrollAxes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onStartNestedScroll</span><span class="params">(View child, View target, <span class="type">int</span> nestedScrollAxes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="type">int</span> nestedScrollAxes)</span> &#123;</span><br><span class="line">        helper.onNestedScrollAccepted(child, target, nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopNestedScroll</span><span class="params">(View target)</span> &#123;</span><br><span class="line">        helper.onStopNestedScroll(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScroll</span><span class="params">(View target, <span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单，主要是注意越界的情况，接下来只要在布局文件里将ChildView设置为ParentView的child就可以了。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>但是这两者到底是怎么样联系起来的呢？我们看看Helper类的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="type">int</span> axes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNestedScrollingParent()) &#123;</span><br><span class="line">        <span class="comment">// Already in progress</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">        <span class="type">ViewParent</span> <span class="variable">p</span> <span class="operator">=</span> mView.getParent();</span><br><span class="line">        <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> mView;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123;</span><br><span class="line">                mNestedScrollingParent = p;</span><br><span class="line">                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                child = (View) p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startNestedScroll是最开始要调用的，作用就是把这个Child和Paren联系起来，内部首先寻找可用的Parent，然后回调Parent的onStartNestedScroll方法，如果返回true，那么就给内部的mNestedScrollingParent赋值同时回调Parent的onNestedScrollAccepted方法，否则mNestedScrollingParent还是null。如果已经有了Parent那么直接返回true，可以知道这个方法调用一次就可以了，只要和Parent联系起来就ok。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed, <span class="type">int</span>[] offsetInWindow)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (offsetInWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">                mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (consumed == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mTempNestedScrollConsumed == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mTempNestedScrollConsumed = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                consumed = mTempNestedScrollConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">            consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            consumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offsetInWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">                mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">            offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先判断isNestedScrollingEnabled和mNestedScrollingParent，如果mNestedScrollingParent＝＝null也就是Parent在onStartNestedScroll返回了false，那么就不会收到这个分发。方法内部回调了Parent的onNestedPreScroll方法，然后判断consume的两个值，如果都是0，那么说明Parent没有消耗，就返回false表示Parent不消耗。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是NestedScrollingChild发出各种事件，比如最开始的startNestedScroll来寻找可用的Parent同时回调Parent的方法，dispatchNestedPreScroll分发偏移量给Parent让它先消耗，而NestedScrollParent只是被动接受各种回调作出处理，比如在onStartNestedScroll返回boolean表示是否接受嵌套滑动，在onNestedPreScroll消耗滑动偏移量。其实高版本的View默认实现了这些方法，但是为了兼容低版本，我们是用Helper来实现，其实实现代码是一样的。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>PagerSlidingTabStrip源码解析</title>
    <url>/2016/07/05/PagerSlidingTabStrip%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>项目地址<a href="https://github.com/astuetz/PagerSlidingTabStrip">https://github.com/astuetz/PagerSlidingTabStrip</a><br>该项目是一个配合ViewPager使用的指示器控件，这里的ViewPager的adapter必须是继承FragmentPagerAdapter，且需要重写getPageIconResId(int position)或者getPageTitle(int position)以便指示器显示内容。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>首先在布局文件中包含PagerSlidingTabTrip和ViewPager</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.astuetz.PagerSlidingTabStrip</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/indicator&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#fff5f5f5&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@drawable/selector_indicator_text_color&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:pstsShouldExpand</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:pstsIndicatorHeight</span>=<span class="string">&quot;4dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:pstsIndicatorColor</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:pstsUnderlineHeight</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:pstsDividerColor</span>=<span class="string">&quot;#fff5f5f5&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/view_pager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 然后绑定ViewPager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indicator = (PagerSlidingTabStrip) findViewById(R.id.indicator);</span><br><span class="line">        viewPager = (ViewPager) findViewById(R.id.view_pager);</span><br><span class="line">        viewPager.setAdapter(<span class="keyword">new</span> <span class="title class_">FragmentAdapter</span>(getFragmentManager()));</span><br><span class="line">        indicator.setViewPager(viewPager);</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是如果要为ViewPager设置OnPageChangeListener应该设置在indicator里，而不是直接为ViewPager设置，至于为什么下面会解释。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>从构造方法开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PagerSlidingTabStrip</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyle)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(context, attrs, defStyle);</span><br><span class="line"></span><br><span class="line">		setFillViewport(<span class="literal">true</span>);</span><br><span class="line">		setWillNotDraw(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		tabsContainer = <span class="keyword">new</span> <span class="title class_">LinearLayout</span>(context);</span><br><span class="line">		tabsContainer.setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">		tabsContainer.setLayoutParams(<span class="keyword">new</span> <span class="title class_">LayoutParams</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">		addView(tabsContainer);</span><br><span class="line"></span><br><span class="line">		<span class="type">DisplayMetrics</span> <span class="variable">dm</span> <span class="operator">=</span> getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">		scrollOffset = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, scrollOffset, dm);</span><br><span class="line">		indicatorHeight = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, indicatorHeight, dm);</span><br><span class="line">		underlineHeight = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, underlineHeight, dm);</span><br><span class="line">		dividerPadding = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerPadding, dm);</span><br><span class="line">		tabPadding = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, tabPadding, dm);</span><br><span class="line">		dividerWidth = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dividerWidth, dm);</span><br><span class="line">		tabTextSize = (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, tabTextSize, dm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get system attrs (android:textSize and android:textColor)</span></span><br><span class="line"></span><br><span class="line">		<span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS);</span><br><span class="line"></span><br><span class="line">		tabTextSize = a.getDimensionPixelSize(<span class="number">0</span>, tabTextSize);</span><br><span class="line">		tabTextColor = a.getColor(<span class="number">1</span>, tabTextColor);</span><br><span class="line"></span><br><span class="line">		a.recycle();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get custom attrs</span></span><br><span class="line"></span><br><span class="line">		a = context.obtainStyledAttributes(attrs, R.styleable.PagerSlidingTabStrip);</span><br><span class="line"></span><br><span class="line">		indicatorColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsIndicatorColor, indicatorColor);</span><br><span class="line">		underlineColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsUnderlineColor, underlineColor);</span><br><span class="line">		dividerColor = a.getColor(R.styleable.PagerSlidingTabStrip_pstsDividerColor, dividerColor);</span><br><span class="line">		indicatorHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsIndicatorHeight, indicatorHeight);</span><br><span class="line">		underlineHeight = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsUnderlineHeight, underlineHeight);</span><br><span class="line">		dividerPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsDividerPadding, dividerPadding);</span><br><span class="line">		tabPadding = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsTabPaddingLeftRight, tabPadding);</span><br><span class="line">		tabBackgroundResId = a.getResourceId(R.styleable.PagerSlidingTabStrip_pstsTabBackground, tabBackgroundResId);</span><br><span class="line">		shouldExpand = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsShouldExpand, shouldExpand);</span><br><span class="line">		scrollOffset = a.getDimensionPixelSize(R.styleable.PagerSlidingTabStrip_pstsScrollOffset, scrollOffset);</span><br><span class="line">		textAllCaps = a.getBoolean(R.styleable.PagerSlidingTabStrip_pstsTextAllCaps, textAllCaps);</span><br><span class="line"></span><br><span class="line">		a.recycle();</span><br><span class="line"></span><br><span class="line">		rectPaint = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">		rectPaint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">		rectPaint.setStyle(Style.FILL);</span><br><span class="line"></span><br><span class="line">		dividerPaint = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">		dividerPaint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">		dividerPaint.setStrokeWidth(dividerWidth);</span><br><span class="line"></span><br><span class="line">		defaultTabLayoutParams = <span class="keyword">new</span> <span class="title class_">LinearLayout</span>.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">		expandedTabLayoutParams = <span class="keyword">new</span> <span class="title class_">LinearLayout</span>.LayoutParams(<span class="number">0</span>, LayoutParams.MATCH_PARENT, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (locale == <span class="literal">null</span>) &#123;</span><br><span class="line">			locale = getResources().getConfiguration().locale;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中先是new了一个LinearLayout作为tab的容器，然后取得一些属性，完成了一些初始化操作。</p>
<p>接下来看一下setViewPager(ViewPager pager)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setViewPager</span><span class="params">(ViewPager pager)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.pager = pager;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pager.getAdapter() == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ViewPager does not have adapter instance.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pager.setOnPageChangeListener(pageListener);</span><br><span class="line"></span><br><span class="line">	notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将viewpager保存起来，然后设置listener，不过这里的listener是一个内部类，等下再来分析这个类，在该方法的最后调用方法notifyDataSetChanged()，我们来看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyDataSetChanged</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	tabsContainer.removeAllViews();</span><br><span class="line"></span><br><span class="line">	tabCount = pager.getAdapter().getCount();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tabCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pager.getAdapter() <span class="keyword">instanceof</span> IconTabProvider) &#123;</span><br><span class="line">			addIconTab(i, ((IconTabProvider) pager.getAdapter()).getPageIconResId(i));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			addTextTab(i, pager.getAdapter().getPageTitle(i).toString());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要完成tab的初始化，没有什么难度。接下来就是比较重要的PageListener类了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PageListener</span> <span class="keyword">implements</span> <span class="title class_">OnPageChangeListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrolled</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line"></span><br><span class="line">		currentPosition = position;</span><br><span class="line">		currentPositionOffset = positionOffset;</span><br><span class="line"></span><br><span class="line">		scrollToChild(position, (<span class="type">int</span>) (positionOffset * tabsContainer.getChildAt(position).getWidth()));</span><br><span class="line"></span><br><span class="line">		invalidate();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (delegatePageListener != <span class="literal">null</span>) &#123;</span><br><span class="line">			delegatePageListener.onPageScrolled(position, positionOffset, positionOffsetPixels);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrollStateChanged</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (state == ViewPager.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">			scrollToChild(pager.getCurrentItem(), <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (delegatePageListener != <span class="literal">null</span>) &#123;</span><br><span class="line">			delegatePageListener.onPageScrollStateChanged(state);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageSelected</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegatePageListener != <span class="literal">null</span>) &#123;</span><br><span class="line">			delegatePageListener.onPageSelected(position);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该控件提供一个setOnPageChangeListener()方法允许用户设置自己的Listener，然后在PageListener类中每个方法都会在listener非空 的情况下调用相应方法。<br>在ViewPager滑动的时候调用scrollToChild方法滑动自身，然后通过invalidata触发onDraw绘制indicator。<br>绘制的主要代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">	<span class="keyword">if</span> (currentPositionOffset &gt; <span class="number">0f</span> &amp;&amp; currentPosition &lt; tabCount - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">View</span> <span class="variable">nextTab</span> <span class="operator">=</span> tabsContainer.getChildAt(currentPosition + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">float</span> <span class="variable">nextTabLeft</span> <span class="operator">=</span> nextTab.getLeft();</span><br><span class="line">		<span class="keyword">final</span> <span class="type">float</span> <span class="variable">nextTabRight</span> <span class="operator">=</span> nextTab.getRight();</span><br><span class="line"></span><br><span class="line">		lineLeft = (currentPositionOffset * nextTabLeft + (<span class="number">1f</span> - currentPositionOffset) * lineLeft);</span><br><span class="line">		lineRight = (currentPositionOffset * nextTabRight + (<span class="number">1f</span> - currentPositionOffset) * lineRight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	canvas.drawRect(lineLeft, height - indicatorHeight, lineRight, height, rectPaint);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>改变一下就可以发现<br>lineLeft &#x3D; lineLeft + (nextTabLeft - lineLeft) * currentPositionOffset<br>lineRight &#x3D; lineRight + (nextTabRight - lineRight) * currentPositionOffset<br>而且nextTabLeft - lineLeft就是当前tab的width，nextTabRight - lineRight是下一个tab的width<br>所以最后就是<br>lineLeft &#x3D; lineLeft + currentWidth * currentPositionOffset<br>lineright &#x3D; lineRight + nextWidth * currentPositionOffset<br>这样的写法可以动态改变indicator的width。<br>值得注意的是我们发现在无论是scrollToChild()还是onDraw()中都用的是tab.getLeft()，那么我们一个一个来分析。<br>在scrollToChild()中，是使用scrollTo()滑动scrollview，tab.getLeft()得到的是相对于父控件的距离，也就是相对于LinearLayout的距离，这样无论怎么滚动，任何tab的left都是不会变的，因为是相对于LinearLayout的距离，而LinearLayout是不会变的。然后根据该left加上偏移量去scrollTo()，就会正好向左滑动让tab靠在最左边。<br>onDraw()中主要是为了绘制indicator，canvas的绘制应该是绘制在本身的，也就是绘制在HorizontalScrollView上的，经过试验发现如果我们draw的left为0，那么会显示在LinearLayout的最左边，也就是说left为0的位置并不是在显示的最左端，而是实际上内容的最左端，可以把整个控件想象为完全展开的，left就是最左边，虽然有可能因为滑动而被挡住，没有显示出来。
			</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Service简析</title>
    <url>/2016/07/11/Service%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Service作为Android的四大组件之一，它的重要性不言而喻，之前虽说看过一些介绍但是一直没有用过，最近需要用到的时候发现无从下手，便阅读了官方的有关Service的Guide，这里总结一下。</p>
<h3 id="Service作用"><a href="#Service作用" class="headerlink" title="Service作用"></a>Service作用</h3><p>官方介绍如下</p>
<blockquote>
<p>A Service is an application component representing either an application’s desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use.</p>
</blockquote>
<p>Service主要用于在后台执行长期任务或者耗时操作，在需要的时候甚至可以在应用退出的时候保持运行状态。</p>
<h3 id="Service与Thread"><a href="#Service与Thread" class="headerlink" title="Service与Thread"></a>Service与Thread</h3><p>虽说Service可以在后台执行任务，但是实际上一个Service是运行在主线程的，如果有耗时操作我们必须在Service中自己开启一个Thread避免ANR。那就会有这么一个问题，我们为什么不用Thread呢？主要的原因就是Thread的可控性不好，假设我们在一个Activity中启动了一个Thread，一旦这个Activity结束了，那么其他的Activity就没有办法拿到这个Thread的引用，更别谈控制了。可是Service不一样，一个Service整个程序只会创建一个实例，而且任何Activity都可以控制，那么Service里的Thread就可以由所有Activity控制了。而且Service作为四大组件之一，有较高级别，在后台运行不容易被系统杀掉。</p>
<h2 id="Service分类"><a href="#Service分类" class="headerlink" title="Service分类"></a>Service分类</h2><p>Service分为两类</p>
<ul>
<li>Started Service：不和其他组件通信</li>
<li>Bound Service：可以和其他组件通信</li>
</ul>
<p> 无论使用哪一种Service都必须重写onBind()方法，如果使用Started Service返回null就可以了。</p>
<h3 id="使用Started-Service"><a href="#使用Started-Service" class="headerlink" title="使用Started Service"></a>使用Started Service</h3><p>一般需要再重写两个方法</p>
<ul>
<li>onCreate():启动Service的时候并不存在该Service实例，就会调用该方法。</li>
<li>onStartCommand(Intent intent, int flags, int startId):每次通过startService(Intent intent)启动的时候就会掉用该方法，一般在这里开启新线程。</li>
</ul>
<p>onStartCommand(Intent intent, int flags, int startId)方法返回int类型的值，代表Service被kill后的行为，有以下三种：</p>
<ul>
<li>START_NOT_STICKY：表示不重新创建</li>
<li>START_STICKY：表示重新创建，调用onStartCommand传入null</li>
<li>START_REDELIVER_INTENT：表示重建，调用onStartCommand传入上一个Intent</li>
</ul>
<p>为了节省资源和电量，我们在任务结束后必须关闭Service，想要关闭Service可以通过本身调用stopSelf()或者其他组件调用stopService(),但是如果我们的Service处理多个onStartCommand请求的时候，我们在请求结束后掉用stopSelf()可能会打断已经收到的新的请求，最好的情况就是我们本身就是最后一个请求，stopSelt(int)的一个参数的重载可以解决这个方法，传入的id就是onStartCommand传递进来的id，代表当前任务的id，它会把传入的id和最后一个id比较，如果一样的话就代表本身是最后一个任务，就会stop掉，否则不会执行stop。</p>
<h3 id="使用Bound-Service"><a href="#使用Bound-Service" class="headerlink" title="使用Bound Service"></a>使用Bound Service</h3><p>主要和Started Service的区别就是可以和其他组件通信，通过Binder。<br>创建时必须定义接口描述用户如何与Server交流，接口必须继承Binder。使用bindService()创建，必须提供一个ServiceConnection的实现，，bindService()是一个异步方法，立马回返回。当创建完后会调用ServiceConnection的onServiceConnected，并传递binder通信。onBind方法只在第一个用户连接调用，后来都返回同一个binder（因为只会有一个Service），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalBinder</span>();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">mGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class used for the client Binder.  Because we know this service always</span></span><br><span class="line"><span class="comment">     * runs in the same process as its clients, we don&#x27;t need to deal with IPC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">        LocalService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Return this instance of LocalService so clients can call public methods</span></span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandomNumber</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bind service的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName className,</span></span><br><span class="line"><span class="params">                IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">// We&#x27;ve bound to LocalService, cast the IBinder and get LocalService instance</span></span><br><span class="line">            <span class="type">LocalBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (LocalBinder) service;</span><br><span class="line">            mService = binder.getService();</span><br><span class="line">            mBound = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName arg0)</span> &#123;</span><br><span class="line">            mBound = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bindService(intent, mConnection, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出我们在Service中自定义了binder继承自Binder，并声明了一个方法，然后在onBind()中返回一个实例。我们会在onServiceConnected方法中得到这个binder，然后我们调用里的方法得到Service的实例，这样就可以掉用里面方法了，也就完成了通信。bindServicer第三个参数是刚开始的选择，如果是BIND_AUTO_CREATE表示如果没启动就新建</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>onServiceDisconnected方法不是unbind的时候调用的，实在被kill等意外情况调用的</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>Toast源码解析</title>
    <url>/2017/05/27/Toast%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="子线程中的Toast"><a href="#子线程中的Toast" class="headerlink" title="子线程中的Toast"></a>子线程中的Toast</h2><p>在写代码的时候发现一个现象，在子线程中使用Toast会crash，错误如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: Can<span class="string">&#x27;t create handler inside thread that has not called Looper.prepare()</span></span><br></pre></td></tr></table></figure>
<p>可以很明显的看出问题出在当前线程企图创建Handler，但是由于本线程没有Looper所以crash了，这时候我不禁对Toast的实现原理产生兴趣，接下来就一步一步的分析源码。</p>
<h2 id="Toast的创建"><a href="#Toast的创建" class="headerlink" title="Toast的创建"></a>Toast的创建</h2><p>在日常使用中都是使用Toast.makeText()来创建一个Toast，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Toast <span class="title function_">makeText</span><span class="params">(Context context, CharSequence text, <span class="meta">@Duration</span> <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="type">Toast</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Toast</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="type">LayoutInflater</span> <span class="variable">inflate</span> <span class="operator">=</span> (LayoutInflater)</span><br><span class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> inflate.inflate(com.android.internal.R.layout.transient_notification, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">    tv.setText(text);</span><br><span class="line">    </span><br><span class="line">    result.mNextView = v;</span><br><span class="line">    result.mDuration = duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很简单，就是设置了mNextView和mDuration，创建一个TextView然后设置传入的String就完成mNextView的设置，mDuration参数被@Duration注解标记，注解如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IntDef(&#123;LENGTH_SHORT, LENGTH_LONG&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Duration &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LENGTH_SHORT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LENGTH_LONG</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>@IntDef限制了只能传入两个给定的int，也就是说我们只能设置显示时间的长短，而无法设置具体的时长。</p>
<h2 id="Toast-show"><a href="#Toast-show" class="headerlink" title="Toast.show()"></a>Toast.show()</h2><p>show()方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNextView == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;setView must have been called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">INotificationManager</span> <span class="variable">service</span> <span class="operator">=</span> getService();</span><br><span class="line">    <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> mContext.getOpPackageName();</span><br><span class="line">    <span class="type">TN</span> <span class="variable">tn</span> <span class="operator">=</span> mTN;</span><br><span class="line">    tn.mNextView = mNextView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Empty</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这里需要得到一个INotificationManager的服务，传入了TN的实例，首先我们先看看TN是什么东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TN</span> <span class="keyword">extends</span> <span class="title class_">ITransientNotification</span>.Stub &#123;</span><br><span class="line"> ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>查看ITransientNotification的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITransientNotification</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">android</span>.app.ITransientNotification</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 省略大部分代码</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这就是一个AIDL的接口，有show()和hide()两个办法，可以猜测主要用于远程服务来控制Toast显示和隐藏的。我们就看看show和hide的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mHide</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        handleHide();</span><br><span class="line">        <span class="comment">// Don&#x27;t do this in handleHide() because it is also invoked by handleShow()</span></span><br><span class="line">        mNextView = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> (IBinder) msg.obj;</span><br><span class="line">        handleShow(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(IBinder windowToken)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;SHOW: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;HIDE: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    mHandler.post(mHide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就用到了Handler，通过Handler实现show和hide，这也就解释了为什么子线程会报错。show()最终调用handlerShow()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleShow</span><span class="params">(IBinder windowToken)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;HANDLE SHOW: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; mView=&quot;</span> + mView</span><br><span class="line">            + <span class="string">&quot; mNextView=&quot;</span> + mNextView);</span><br><span class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</span><br><span class="line">        <span class="comment">// remove the old view if necessary</span></span><br><span class="line">        handleHide();</span><br><span class="line">        mView = mNextView;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> mView.getContext().getApplicationContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> mView.getContext().getOpPackageName();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">            context = mView.getContext();</span><br><span class="line">        &#125;</span><br><span class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></span><br><span class="line">        <span class="comment">// the layout direction</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> mView.getContext().getResources().getConfiguration();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</span><br><span class="line">        mParams.gravity = gravity;</span><br><span class="line">        <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</span><br><span class="line">            mParams.horizontalWeight = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</span><br><span class="line">            mParams.verticalWeight = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mParams.x = mX;</span><br><span class="line">        mParams.y = mY;</span><br><span class="line">        mParams.verticalMargin = mVerticalMargin;</span><br><span class="line">        mParams.horizontalMargin = mHorizontalMargin;</span><br><span class="line">        mParams.packageName = packageName;</span><br><span class="line">        mParams.hideTimeoutMilliseconds = mDuration ==</span><br><span class="line">            Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</span><br><span class="line">        mParams.token = windowToken;</span><br><span class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;REMOVE! &quot;</span> + mView + <span class="string">&quot; in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">            mWM.removeView(mView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;ADD! &quot;</span> + mView + <span class="string">&quot; in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        mWM.addView(mView, mParams);</span><br><span class="line">        trySendAccessibilityEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出主要就是通过WindowManager来addView显示Toast。hide()最终调用handleHide方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleHide</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;HANDLE HIDE: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; mView=&quot;</span> + mView);</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// note: checking parent() just to make sure the view has</span></span><br><span class="line">        <span class="comment">// been added...  i have seen cases where we get here when</span></span><br><span class="line">        <span class="comment">// the view isn&#x27;t yet added, so let&#x27;s try not to crash.</span></span><br><span class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;REMOVE! &quot;</span> + mView + <span class="string">&quot; in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">            mWM.removeViewImmediate(mView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mView = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是通过WindowManager来removevView。</p>
<h2 id="Toast的时长"><a href="#Toast的时长" class="headerlink" title="Toast的时长"></a>Toast的时长</h2><p>我们在使用Toast的时候只能穿入LENGTH_LONG活着LENGTH_SHORT两个变量，而具体的时间在handleShow()的代码中可以发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mParams.hideTimeoutMilliseconds = mDuration ==</span><br><span class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SHORT_DURATION_TIMEOUT</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">LONG_DURATION_TIMEOUT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出长短时间分别对应5秒和1秒</p>
<h2 id="为何使用AIDL而不是自己控制显示和隐藏"><a href="#为何使用AIDL而不是自己控制显示和隐藏" class="headerlink" title="为何使用AIDL而不是自己控制显示和隐藏"></a>为何使用AIDL而不是自己控制显示和隐藏</h2><p>不知道大家有没有发现，在显示两个Toast的时候，总是第一个显示完毕才会显示第二个，如果让Toast自己控制，那么是很难实现这样的效果的，它并不知道其他Toast的状态，所以所有Toast交由系统同意管理，通过队列来依次显示Toast，并会按照设置的时间来hide Toast。</p>
<h2 id="如何自己控制时间"><a href="#如何自己控制时间" class="headerlink" title="如何自己控制时间"></a>如何自己控制时间</h2><p>我们可以跳过AIDL，获取NT对象，直接调用show和hide方法，但是NT对象构造方法是私有的，我们可以通过反射来解决，当然也可以反射设置time，然后正常show。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin协程</title>
    <url>/2019/03/21/kotlin%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h1><blockquote>
<p>协程实际上是一个轻量级的线程，可以挂起并稍后恢复</p>
</blockquote>
<p>kotlin中，协程把异步编程放入库中来简化这类操作。程序逻辑在协程中顺序表述，而底层的库会将其转换为异步操作。库会将相关的用户代码打包成回调，调度其执行到不同的线程，而代码依然像顺序执行那么简单。</p>
<h1 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h1><p>协程主要是让原来要使用“异步+回调”写出来的复杂代码，简化成看起来是同步的代码，本质上是callback的语法糖。</p>
<h1 id="kotlin标准库提供的基本的元素-操作"><a href="#kotlin标准库提供的基本的元素-操作" class="headerlink" title="kotlin标准库提供的基本的元素&#x2F;操作"></a>kotlin标准库提供的基本的元素&#x2F;操作</h1><h2 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h2><p>Kotlin在1.1版本新增加了 suspend 关键字，可以用来修饰函数或者 lambda 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">suspend fun <span class="title function_">suspendFun</span><span class="params">()</span>: String &#123;&#125;</span><br><span class="line">val suspendLambda1: suspend () -&gt; String = &#123;&#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">suspendLambda2</span> <span class="operator">=</span> suspend &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>被suspend修饰的方法只能在另一个suspend方法或者一个协程中被调用，suspend表示这个方法是一个可中断挂起的方法</p>
<h2 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h2><p>CoroutineContext是协程的上下文，表示一系列用户自定义的Object，也就是代表代码块执行在哪个场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E?</span><br><span class="line">    fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R</span><br><span class="line">    operator fun <span class="title function_">plus</span><span class="params">(context: CoroutineContext)</span>: CoroutineContext</span><br><span class="line">    fun <span class="title function_">minusKey</span><span class="params">(key: Key&lt;*&gt;)</span>: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get：获取当前指定Key对应的Context</li>
<li>fold：类似集合的fold方法，用于累加</li>
<li>plus：重载操作符plus，使得context之间可以用’+’符号运算获得一个新的context</li>
<li>minusKey：获得除指定Key对应的Context之外的所有Context</li>
</ul>
<h2 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h2><p>表示协程中的执行单元</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;in T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> val context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ContinuationInterceptor"><a href="#ContinuationInterceptor" class="headerlink" title="ContinuationInterceptor"></a>ContinuationInterceptor</h2><p>Continuation的拦截器，继承自CoroutineContext，如果当协程的Context包含ContinuationInterceptor那么当前协程内所有的Continuation在执行前都会经过拦截器的替换。</p>
<h2 id="创建和启动协程"><a href="#创建和启动协程" class="headerlink" title="创建和启动协程"></a>创建和启动协程</h2><p>创建协程的方式很简单，我们需要一个suspend lambda和一个Continuation，标准库为suspend lambda定义了扩展方法startCoroutine</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion).intercepted().resume(Unit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法创建并启动一个协程，该协程的Context由传入的Continuation提供，且lambda执行完毕后回调该Continuation的resumeWith方法</p>
<h2 id="挂起-恢复协程"><a href="#挂起-恢复协程" class="headerlink" title="挂起&#x2F;恢复协程"></a>挂起&#x2F;恢复协程</h2><p>通过在一个协程中调用标准库提供的suspendContinue方法来挂起当前协程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T =</span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;</span><br><span class="line">        <span class="type">val</span> <span class="variable">safe</span> <span class="operator">=</span> SafeContinuation(c.intercepted())</span><br><span class="line">        block(safe)</span><br><span class="line">        safe.getOrThrow()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个参数为Continuation的lambda，开始执行该lambda并挂起当前协程，如果想要恢复协程的执行，通过调用传入的Continuation的resumeWith方法来恢复</p>
<h1 id="Kotlinx提供的协程库"><a href="#Kotlinx提供的协程库" class="headerlink" title="Kotlinx提供的协程库"></a>Kotlinx提供的协程库</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.1&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对基础库协程的封装，提供更加简洁的api</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;launch 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;launch 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>可挂起的方法采用CPS(Continuation-Passing-Style)实现，每一个可挂起的方法被调用的时候都会被隐式的传递一个Continuation参数来表示后续的操作。</p>
<p>采用Continuation则是一种函数调用方式，它不采用堆栈来保存上下文，而是把这些信息保存在continuation record中。这些continuation record和堆栈的activation record的区别在于，它不采用后入先出的线性方式，所有record被组成一棵树（或者图），从一个函数调用另一个函数就等于给当前节点生成一个子节点，然后把系统寄存器移动到这个子节点。一个函数的退出等于从当前节点退回到父节点。<br>最大的好处就是，它可以让你从任意一个节点跳到另一个节点。而不必遵循堆栈方式的一层一层的return方式。比如说，在当前的函数内，你只要有一个其它函数的节点信息，完全可以选择return到那个函数，而不是循规蹈矩地返回到自己的调用者。你也可以在一个函数的任何位置储存自己的上下文信息，然后，在以后某个适当的时刻，从其它的任何一个函数里面返回到自己现在的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">a</span> <span class="operator">=</span> a()</span><br><span class="line"><span class="type">val</span> <span class="variable">y</span> <span class="operator">=</span> foo(a).await() <span class="comment">// suspension point #1</span></span><br><span class="line">b()</span><br><span class="line"><span class="type">val</span> <span class="variable">z</span> <span class="operator">=</span> bar(a, y).await() <span class="comment">// suspension point #2</span></span><br><span class="line">c(z)</span><br><span class="line"></span><br><span class="line">class &lt;anonymous_for_state_machine&gt; <span class="keyword">extends</span> <span class="title class_">SuspendLambda</span>&lt;...&gt; &#123;</span><br><span class="line">    <span class="comment">// The current state of the state machine</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// local variables of the coroutine</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line">    <span class="type">Y</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="number">0</span>) <span class="keyword">goto</span> L0</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(label == <span class="number">1</span>)</span> <span class="keyword">goto</span> L1</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(label == <span class="number">2</span>)</span> <span class="keyword">goto</span> L2</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">        </span><br><span class="line">      L0:</span><br><span class="line">        <span class="comment">// result is expected to be `null` at this invocation</span></span><br><span class="line">        a = a()</span><br><span class="line">        label = <span class="number">1</span></span><br><span class="line">        result = foo(a).await(<span class="built_in">this</span>) <span class="comment">// &#x27;this&#x27; is passed as a continuation </span></span><br><span class="line">        <span class="keyword">if</span> (result == COROUTINE_SUSPENDED) <span class="keyword">return</span> <span class="comment">// return if await had suspended execution</span></span><br><span class="line">      L1:</span><br><span class="line">        <span class="comment">// external code has resumed this coroutine passing the result of .await() </span></span><br><span class="line">        y = (Y) result</span><br><span class="line">        <span class="title function_">b</span><span class="params">()</span></span><br><span class="line">        label = <span class="number">2</span></span><br><span class="line">        result = bar(a, y).await(<span class="built_in">this</span>) <span class="comment">// &#x27;this&#x27; is passed as a continuation</span></span><br><span class="line">        <span class="keyword">if</span> (result == COROUTINE_SUSPENDED) <span class="keyword">return</span> <span class="comment">// return if await had suspended execution</span></span><br><span class="line">      L2:</span><br><span class="line">        <span class="comment">// external code has resumed this coroutine passing the result of .await()</span></span><br><span class="line">        <span class="type">Z</span> <span class="variable">z</span> <span class="operator">=</span> (Z) result</span><br><span class="line">        <span class="title function_">c</span><span class="params">(z)</span></span><br><span class="line">        label = -<span class="number">1</span> <span class="comment">// No more steps are allowed</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ViewModel支持的协程"><a href="#ViewModel支持的协程" class="headerlink" title="ViewModel支持的协程"></a>ViewModel支持的协程</h1><p><a href="https://craigrussell.io/2019/03/coroutine-support-in-viewmodels-using-the-new-viewmodelscope-extension-property/">https://craigrussell.io/2019/03/coroutine-support-in-viewmodels-using-the-new-viewmodelscope-extension-property/</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-context">https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#coroutine-context</a><br><a href="https://www.cnblogs.com/cheukyin/p/6444860.html">https://www.cnblogs.com/cheukyin/p/6444860.html</a></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的创建与遍历</title>
    <url>/2017/02/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树创建"><a href="#二叉树创建" class="headerlink" title="二叉树创建"></a>二叉树创建</h2><p>创建根据数组，值为0代表空节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= data.length || data[index] == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">	node.setValue(data[index]);</span><br><span class="line">	node.setLeftChild(createTree(data, <span class="number">2</span> * index + <span class="number">1</span>));</span><br><span class="line">	node.setRightChild(createTree(data, <span class="number">2</span> * index + <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createTree是创建以index索引代表节点为root的树，所以我们首先创建节点赋上对应值，然后设置左右子树，通过递归，最后得到二叉树。</p>
<h2 id="二叉树的深度优先遍历的递归算法"><a href="#二叉树的深度优先遍历的递归算法" class="headerlink" title="二叉树的深度优先遍历的递归算法"></a>二叉树的深度优先遍历的递归算法</h2><p>深度优先遍历还分为先序、中序、后序。以先序为例，先序就是先访问根节点，再先序遍历左子树，然后先序遍历右子树，很明显可以递归完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">		System.out.println(root.getValue() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		preOrder(root.getLeftChild());</span><br><span class="line">		preOrder(root.getRightChild());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">		preOrder(root.getLeftChild());</span><br><span class="line">		System.out.println(root.getValue() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		preOrder(root.getRightChild());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">		preOrder(root.getLeftChild());</span><br><span class="line">		preOrder(root.getRightChild());</span><br><span class="line">		System.out.println(root.getValue() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的深度优先遍历的非递归算法"><a href="#二叉树的深度优先遍历的非递归算法" class="headerlink" title="二叉树的深度优先遍历的非递归算法"></a>二叉树的深度优先遍历的非递归算法</h2><h3 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h3><p>非递归方法我们使用栈来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序非递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ArrayDeque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">	stack.push(node);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">		System.out.println(n.getValue() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (n.getRightChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(n.getRightChild());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n.getLeftChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(n.getLeftChild());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先root入栈，然后循环访问栈顶元素并出栈，接下来将左右子节点入栈，入栈顺序要是先右后左。</p>
<h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>通过观察可以发现将后序的结果反过来就相当于将二叉树所有左右子树互换后的先序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序非递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ArrayDeque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">	List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	stack.push(node);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">		<span class="comment">// 加到队列开头</span></span><br><span class="line">		result.add(<span class="number">0</span>, n.getValue());</span><br><span class="line">		<span class="keyword">if</span> (n.getLeftChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(n.getLeftChild());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n.getRightChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(n.getRightChild());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先root入栈，然后循环访问栈顶元素并出栈，接下来将左右子节点入栈，入栈顺序要是先右后左。</p>
<h2 id="前-中-后序非递归遍历的通用解法"><a href="#前-中-后序非递归遍历的通用解法" class="headerlink" title="前&#x2F;中&#x2F;后序非递归遍历的通用解法"></a>前&#x2F;中&#x2F;后序非递归遍历的通用解法</h2><p>以后序为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; traversal(TreeNode root) &#123;</span><br><span class="line">    	// 等待访问的节点</span><br><span class="line">        Stack&lt;TreeNode&gt; toVisitStack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">        // 访问节点的顺序</span><br><span class="line">        List&lt;TreeNode&gt; visitQueue = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        visitQueue.add(root);</span><br><span class="line">        toVisitStack.push(root);</span><br><span class="line">        while (!toVisitStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = toVisitStack.pop();</span><br><span class="line">            visitNode(node, visitQueue, toVisitStack);</span><br><span class="line">        &#125;</span><br><span class="line">        for (TreeNode treeNode : visitQueue) &#123;</span><br><span class="line">            result.add(treeNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 后序</span><br><span class="line">    private void visitNode(TreeNode node, List&lt;TreeNode&gt; visitQueue, Stack&lt;TreeNode&gt; toVisitStack) &#123;</span><br><span class="line">        int index = visitQueue.indexOf(node);</span><br><span class="line">        if (node.left != null) &#123;</span><br><span class="line">            visitQueue.add(index, node.left);</span><br><span class="line">            toVisitStack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        index = visitQueue.indexOf(node);</span><br><span class="line">        if (node.right != null) &#123;</span><br><span class="line">            visitQueue.add(index, node.right);</span><br><span class="line">            toVisitStack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class TreeNode &#123;</span><br><span class="line">      int val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(int x) &#123;</span><br><span class="line">          val = x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>visitQueue保存的是最后所有节点的访问顺序，从index&#x3D;0开始，首先我们将root加入visitQueue和toVisitStack，随后从toVisitStack中获取visitNode，将子节点插入visitQueue，这里以后序为例，左右节点均在当前节点之前访问且左节点优先于右节点，所以在visitQueue中的当前节点位置之前插入左右节点，随后将左右节点加入toVisitStack表示后序将对左右节点进行上述操作。</p>
<h2 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h2><p>我们可以通过一个队列来保存访问过的节点的左右子节点，然后删除访问过的节点，直到队列为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">layer</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Node&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">	nodeQueue.add(root);</span><br><span class="line">	<span class="keyword">while</span> (nodeQueue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeQueue.remove(<span class="number">0</span>);</span><br><span class="line">		System.out.println(node.getValue() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.getLeftChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			nodeQueue.add(node.getLeftChild());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.getRightChild() != <span class="literal">null</span>) &#123;</span><br><span class="line">			nodeQueue.add(node.getRightChild());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>为RecyclerView添加load more功能</title>
    <url>/2018/09/23/%E4%B8%BARecyclerView%E6%B7%BB%E5%8A%A0loadmore%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>实现LoadMore功能主要是从Adapter入手，通过在onAttachedToRecyclerView方法里给RecyclerView添加滑动监听来实现。一种思路是实现一个LoadMoreAdapter基类让其他的Adapter继承来获得load more的能力，但是这样的实现方式感觉有点侵入原有的Adapter代码，而且不够灵活，所以本文采用代理原有Adapter的方式来实现。</p>
<h1 id="实现FooterView"><a href="#实现FooterView" class="headerlink" title="实现FooterView"></a>实现FooterView</h1><p>第一步先来实现FooterView，我们定义一个FooterView的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFooterView</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changState</span><span class="params">(LoadingState state)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中LoadingState是load more的状态，有如下几种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LoadingState</span> &#123;</span><br><span class="line">    LOADING_STATE_NO_MORE, <span class="comment">// 没有更多</span></span><br><span class="line">    LOADING_STATE_LOADING, <span class="comment">// 加载中</span></span><br><span class="line">    LOADING_STATE_ERROR, <span class="comment">// 加载错误</span></span><br><span class="line">    LOADING_STATE_NORMAL <span class="comment">// 不显示footer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们实现一个默认的FooterView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFooterView</span> <span class="keyword">extends</span> <span class="title class_">RelativeLayout</span> <span class="keyword">implements</span> <span class="title class_">IFooterView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProgressBar mLoadingView;</span><br><span class="line">    <span class="keyword">private</span> TextView mNoMoreView;</span><br><span class="line">    <span class="keyword">private</span> TextView mErrorView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadMoreAdapter.<span class="type">LoadingState</span> <span class="variable">mState</span> <span class="operator">=</span> LoadMoreAdapter.LoadingState.LOADING_STATE_NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultFooterView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultFooterView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultFooterView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        inflate(getContext(), R.layout.default_footer_layout, <span class="built_in">this</span>);</span><br><span class="line">        mLoadingView = (ProgressBar) findViewById(R.id.loading_view);</span><br><span class="line">        mNoMoreView = (TextView) findViewById(R.id.no_more_view);</span><br><span class="line">        mErrorView = (TextView) findViewById(R.id.error_view);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changState</span><span class="params">(LoadMoreAdapter.LoadingState state)</span> &#123;</span><br><span class="line">        mState = state;</span><br><span class="line">        mLoadingView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_LOADING? VISIBLE: GONE);</span><br><span class="line">        mNoMoreView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_NO_MORE? VISIBLE: GONE);</span><br><span class="line">        mErrorView.setVisibility(mState == LoadMoreAdapter.LoadingState.LOADING_STATE_ERROR? VISIBLE: GONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的布局就不展示了，各位自由发挥。如上所示，FooterView对外提供changeState方法来改变布局为对应的状态。</p>
<h1 id="实现LoadMoreAdapter"><a href="#实现LoadMoreAdapter" class="headerlink" title="实现LoadMoreAdapter"></a>实现LoadMoreAdapter</h1><p>LoadMoreAdapter用来代理一个真正的Adapter，将相关的系统回调传递给Adapter并实现load more的功能，而在外部RecyclerView使用LoadMoreAdapter而不是被代理的Adapter。</p>
<h3 id="代理Adapter"><a href="#代理Adapter" class="headerlink" title="代理Adapter"></a>代理Adapter</h3><p>创建LoadMoreAdapter需要传入一个Adapter，LoadMoreAdapter保存这个Adapter并在相关的系统回调方法里触发Adapter相应的回调，如下所示方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasStableIds</span><span class="params">(<span class="type">boolean</span> hasStableIds)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.setHasStableIds(hasStableIds);</span><br><span class="line">    mAdapter.setHasStableIds(hasStableIds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; mAdapter.getItemCount() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getItemId(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAdapter.getItemId(position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewRecycled</span><span class="params">(RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> FooterViewHolder) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewRecycled(holder);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAdapter.onViewRecycled(holder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onFailedToRecycleView</span><span class="params">(RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> FooterViewHolder) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onFailedToRecycleView(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAdapter.onFailedToRecycleView(holder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewAttachedToWindow</span><span class="params">(RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> FooterViewHolder) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewAttachedToWindow(holder);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAdapter.onViewAttachedToWindow(holder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewDetachedFromWindow</span><span class="params">(RecyclerView.ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> FooterViewHolder) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewDetachedFromWindow(holder);</span><br><span class="line">    &#125;</span><br><span class="line">    mAdapter.onViewDetachedFromWindow(holder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAdapterDataObserver</span><span class="params">(RecyclerView.AdapterDataObserver observer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.registerAdapterDataObserver(observer);</span><br><span class="line">    mAdapter.registerAdapterDataObserver(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterAdapterDataObserver</span><span class="params">(RecyclerView.AdapterDataObserver observer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.unregisterAdapterDataObserver(observer);</span><br><span class="line">    mAdapter.unregisterAdapterDataObserver(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中mAdapter.registerAdapterDataObserver(observer);方法必须要写，因为只有这样才会在调用Adapter的notify方法的时候通知到RecyclerView来刷新数据。</p>
<h3 id="实现LoadMore"><a href="#实现LoadMore" class="headerlink" title="实现LoadMore"></a>实现LoadMore</h3><p>LoadMoreAdapter内部保存一个当前的state，通过这个state来判断当前是否应该显示footer，主要是通过getItemCount()、getItemViewType()、onCreateViewHolder()、onBindViewHolder()四个方法来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (viewType == TYPE_FOOT) &#123;</span><br><span class="line">        <span class="type">IFooterView</span> <span class="variable">footView</span> <span class="operator">=</span> (View) <span class="keyword">new</span> <span class="title class_">DefaultFooterView</span>(mContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FooterViewHolder</span>(footView);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAdapter.onCreateViewHolder(parent, viewType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> FooterViewHolder) &#123;</span><br><span class="line">        <span class="type">FooterViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> (FooterViewHolder) holder;</span><br><span class="line">        viewHolder.bind(mState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAdapter.onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mAdapter.getItemCount() + (mState == LoadingState.LOADING_STATE_NORMAL? <span class="number">0</span>: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemViewType</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position == mAdapter.getItemCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> TYPE_FOOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAdapter.getItemViewType(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>且对外提供一个方法来改变当前的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLoadMoreState</span><span class="params">(LoadingState state)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkState(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = state;</span><br><span class="line">    notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然真正的LoadMore逻辑是在onAttachedToRecyclerView的时候给RecyclerView添加滑动监听来实现的，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAttachedToRecyclerView</span><span class="params">(RecyclerView recyclerView)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">    mAdapter.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">    mRecyclerView = recyclerView;</span><br><span class="line">    mRecyclerView.addOnScrollListener(mScrollerListener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initScrollListener</span><span class="params">()</span> &#123;</span><br><span class="line">    mScrollerListener = <span class="keyword">new</span> <span class="title class_">RecyclerView</span>.OnScrollListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="type">int</span> newState)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="type">int</span> dx, <span class="type">int</span> dy)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">showLoadMore</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            showLoadMore = !recyclerView.canScrollVertically(<span class="number">1</span>) &amp;&amp; dy &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (showLoadMore) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mLoadMoreListener != <span class="literal">null</span> &amp;&amp; mState != LoadingState.LOADING_STATE_LOADING) &#123;</span><br><span class="line">                    mState = LoadingState.LOADING_STATE_LOADING;</span><br><span class="line">                    notifyDataSetChanged();</span><br><span class="line">                    mLoadMoreListener.onLoadMore();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnLoadMoreListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadMore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RecyclerView要向上滑动但不能向上滑的时候触发LoadMore(当前不处于loading的时候)，后面就要求外部在加载结束后调用LoadMoreAdapter的updateLoadMoreState方法来更新状态。</p>
<h1 id="实现过程中的坑"><a href="#实现过程中的坑" class="headerlink" title="实现过程中的坑"></a>实现过程中的坑</h1><p>原来的思路是itemCount写死mAdapter.getItemCount + 1,然后在不现实footer的时候让FooterView内部的View都gone，然后设置高度为0，看起来就相当于没有FooterView。但是RecyclerView貌似会对布局中元素都是gone或者空布局做一些优化，导致canScrollVertically始终返回true，所以后来采用了更改itemCount的方法。</p>
]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title>交换排序之快速排序</title>
    <url>/2016/03/17/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序的基本思路是选取一个基准数，然后将小于基准数的移到基准数左边，反之在右边，称为一趟快速排序。然后以基准数分为左右两组，分别快速排序，如此递归，完成最终排序。</p>
<p>一般基准数选取第一个数据，接下来重点在于一趟排序中如何移动数据。如数据data[] &#x3D; {4 3 6 2 1}，data[0] &#x3D; 4为基准，将4搬出，则data[0]一个空位，设置标志位i &#x3D; 0, j &#x3D; 4。先递减j，因为右边的是大于4的，所以找到小于4的移到左边的空位，然后递增i找到大于4的移到之前j移动后的空位 如此反复直到i ＝ j结束。此时i ＝ j肯定是一个空位 将4移动到这，第一趟结束，接下来递归就可以了。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> *data, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排序结束</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> base = data[left];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    <span class="comment">//循环直到i＝j</span></span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="comment">//先从右边开始，因为基准取的是第一个数据</span></span><br><span class="line">        <span class="comment">//当数据大于基准数继续递减</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[j] &gt;= base) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果i&lt;j 则data[j] &lt; base，移动</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            data[i] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; data[i] &lt;= base) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            data[j] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后移动基准数</span></span><br><span class="line">    data[i] = base;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(data, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(data, i + <span class="number">1</span>, right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(data, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != N; i++) &#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2018/11/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>远程代理：也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实(Binder机制)。</li>
<li>保护代理：用来控制真实对象访问时的权限。</li>
<li>智能引用代理：当调用目标对象时，代理可以处理其他的一些操作。</li>
</ul>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="/images/proxy1.png" alt="代理模式"></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在编写代码期间为每个被代理的对象编写对应的代理类，达到对应的代理功能</p>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RealStudent</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealStudent</span>();</span><br><span class="line">        <span class="type">IStudent</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentProxy</span>(student);</span><br><span class="line">        s.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理类，真正的执行者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RealStudent</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;doing homework...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentProxy</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> IStudent realStudent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentProxy</span><span class="params">(IStudent realStudent)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.realStudent = realStudent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (realStudent != <span class="literal">null</span>) &#123;</span><br><span class="line">                realStudent.doHomework();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：<br>WeakHandler</p>
<p>优点：在编译期加入，提前就指定好了谁调用谁，效率高。<br>缺点：如果要想为多个类进行代理，则需要建立多个代理类，维护难度加大。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>由于每一个静态代理类只能为一个接口服务，工程中有可能产生很多代理类，所以我们就会想办法可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理</p>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">RealStudent</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealStudent</span>();</span><br><span class="line">        Class&lt;?&gt;[] inters = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IStudent.class&#125;;</span><br><span class="line">        <span class="type">IStudent</span> <span class="variable">s</span> <span class="operator">=</span> (IStudent) Proxy.newProxyInstance(student.getClass().getClassLoader(), inters, <span class="keyword">new</span> <span class="title class_">StudentProxy</span>(student));</span><br><span class="line">        s.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理类，真正的执行者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RealStudent</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;doing homework...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> IStudent realStudent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentProxy</span><span class="params">(IStudent realStudent)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.realStudent = realStudent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="keyword">if</span> (realStudent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(realStudent, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理原理：<br>运行时按照Class文件标准格式结合JNI的defineClass0()方法生成Proxy匿名代理类，该类实现了需要代理的接口，并返回这个代理类的实例对象给调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存Proxy生成的中间类到根目录</span></span><br><span class="line">System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>实例：<br>Retrofit</p>
<p>优点：高扩展性<br>缺点：</p>
<ol>
<li>实现比静态代理复杂，不好理解</li>
<li>要求代理对象必须实现了某个接口</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>使用ItemDecoration打造列表顶部悬浮效果</title>
    <url>/2017/01/13/%E4%BD%BF%E7%94%A8ItemDecoration%E6%89%93%E9%80%A0%E5%88%97%E8%A1%A8%E9%A1%B6%E9%83%A8%E6%82%AC%E6%B5%AE%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="ItemDecoration基本用法"><a href="#ItemDecoration基本用法" class="headerlink" title="ItemDecoration基本用法"></a>ItemDecoration基本用法</h1><p>ItemDecoration是用来给RecyclerView添加分隔线的，我们可以通过自定义ItemDecoration来实现各种效果，我们先来看一下基本用法。<br>首先我们继承ItemDecoration，要实现三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.onDraw(c, parent, state);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawOver</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.onDrawOver(c, parent, state);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getItemOffsets():使用这个方法来给其中一个item（view）添加间隔，用来绘制分割线，比如我们通过parent.getChildAdapterPosition(view)得到这个item的position，然后我们使用outRect.top &#x3D; 100来使这个item的上面多出100高度的矩形空间用来绘制，对应的left之类的可以类比。</li>
<li>onDraw():用来绘制分割线，一般在这个方法里遍历parent的全部child，然后得到position（注意这里的child只能得到展示在页面的，所以需要额外计算得到真实的position）根据情况看看需不需要绘制分割线。</li>
<li>onDrawOver():和onDraw()很像，区别在于这个绘制的显示在最上方，原因马上说。</li>
</ul>
<p>在RecyclerView绘制的时候，首先调用onDraw绘制分割线，然后调用自身的onDraw绘制自己（各种item），最后调用onDrawOver绘制，三个绘制用的一个Canvas，所以最后绘制的会覆盖之前的。</p>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>刚看理论肯定云里雾里，这时候就需要敲代码来加深理解和记忆了，我们要完成的效果如下<br><img src="/images/item-dec.gif" alt="这里写图片描述"></p>
<h2 id="在RecyclerView中添加数据"><a href="#在RecyclerView中添加数据" class="headerlink" title="在RecyclerView中添加数据"></a>在RecyclerView中添加数据</h2><p>data</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] data = &#123;<span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>, <span class="string">&quot;1-你好&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>, <span class="string">&quot;2-OK&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>, <span class="string">&quot;3-你好&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>, <span class="string">&quot;4-OK&quot;</span>,&#125;;</span><br></pre></td></tr></table></figure>

<p>Adapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; adapter = <span class="keyword">new</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span>  LayoutInflater.from(MainActivity.<span class="built_in">this</span>).inflate(R.layout.item_layout, parent, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyViewHolder</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="type">MyViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> (MyViewHolder) holder;</span><br><span class="line">        viewHolder.textView.setText(data[position]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TextView textView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyViewHolder</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            textView = (TextView) itemView.findViewById(R.id.text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>item_layout</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;1dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="给每一组前面添加组名"><a href="#给每一组前面添加组名" class="headerlink" title="给每一组前面添加组名"></a>给每一组前面添加组名</h2><p>首先我们需要两个方法分别判断是不是该组第一个item和返回改组的组名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getGroupName</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;第&quot;</span> + (index / <span class="number">7</span> + <span class="number">1</span>) + <span class="string">&quot;组&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFirstOfGroup</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index % <span class="number">7</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们先对每一组第一个item上部添加空间来绘制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> parent.getChildAdapterPosition(view);</span><br><span class="line">    <span class="keyword">if</span> (isFirstOfGroup(index)) &#123;</span><br><span class="line">        outRect.top = mTopHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里mTopHeight是组名的高度，然后我们开始绘制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDraw(c, parent, state);</span><br><span class="line">    <span class="comment">// 得到item真实的left和right（减去parent的padding）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent.getPaddingLeft();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> parent.getWidth() - parent.getPaddingRight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != parent.getChildCount(); i++) &#123;</span><br><span class="line">        <span class="comment">// 直接获得的child只有当前显示的，所以就算i是0的index也只是当前第一个，而不是所有第一个</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> parent.getChildAt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> parent.getChildAdapterPosition(child);</span><br><span class="line">        <span class="keyword">if</span> (isFirstOfGroup(index)) &#123;</span><br><span class="line">         <span class="comment">// 每组第一个item都留有空间来绘制</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> child.getTop() - mTopHeight;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> child.getTop();</span><br><span class="line">            <span class="comment">// 绘制背景色</span></span><br><span class="line">            <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">            paint.setColor(Color.YELLOW);</span><br><span class="line">            c.drawRect(left, top, right, bottom, paint);</span><br><span class="line">            <span class="comment">// 绘制组名</span></span><br><span class="line">            paint.setColor(Color.BLACK);</span><br><span class="line">            paint.setTextSize(<span class="number">60</span>);</span><br><span class="line">            paint.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">            paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">            c.drawText(getGroupName(index), left, bottom, paint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="/images/item-dec1.gif" alt="这里写图片描述"></p>
<h2 id="添加顶部悬浮"><a href="#添加顶部悬浮" class="headerlink" title="添加顶部悬浮"></a>添加顶部悬浮</h2><p>我们先来分析一下，平常情况就是顶部绘制一个组名，我们可以通过onDrawOver来覆盖后面的内容达到悬浮的效果。当我们目前页面第二个item是下一组的第一个item的时候情况就不一样了（也就是下一个组马上就要到达顶部的时候），我们的顶部组就会向上发生偏移（像被顶上去的样子），这时候我们只需要计算绘制的bottom是多少就好了（top就是0）。我们可以这样来做</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isFirstOfGroup(index + <span class="number">1</span>)) &#123;</span><br><span class="line"> <span class="comment">// 下一个组马上到达顶部</span></span><br><span class="line">    bottom = Math.min(child.getBottom(), mTopHeight);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通情况</span></span><br><span class="line">    bottom = mTopHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一个组马上到达顶部的时候，我们选择mTopHeight和child.getBottom()中比较小的来作为bottom，这样就可以保证，当悬浮组名bottom超过该组最后一个item的bottom的时候改为最后一个item的bottom，最后消失。<br>最后看一下效果<br><img src="/images/item-dec2.gif" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title>仿头条实现EditText的hint上下滚动轮播效果</title>
    <url>/2018/10/21/%E4%BB%BF%E5%A4%B4%E6%9D%A1%E5%AE%9E%E7%8E%B0EditText%E7%9A%84hint%E4%B8%8A%E4%B8%8B%E6%BB%9A%E5%8A%A8%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近看到头条的首页顶部搜索框有一个切换hint文字的动画效果，比较好奇它是怎么实现的，经过一番探索发现这个顶部的搜索框并不是真正的搜索框，点击之后是直接跳转到搜索界面，本身并不是一个EditText。这样的实现方式让我顿时感觉索然无味，同时不禁思考，难道不能在一个EditText控件上实现这样的效果吗？百度、google了一番发现并没有找到相关的效果实现，于是决定自己撸一个。起初并没有头绪，后来想起来google官方出的TextInputLayout好像有涉及到EditText的hint动画效果，就研究了一番TextInputLayout的源码，并参考源码实现本文的hint轮播效果。头条与本文实现的效果如下图<br><img src="/images/autohint1.gif" alt="在这里插入图片描述"><br><img src="/images/autohint2.gif" alt="在这里插入图片描述"></p>
<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>通过阅读TextInputLayout的源码发现hint的绘制其实不是EditText绘制的，而是TextInpuLayout来进行绘制，它通过获得子控件EditText的hint绘制区域，来自己完成hint相关的绘制与动画操作，而EditText是不设置hint的。有了这个思路，我们就可以开发本文要介绍的控件AutoHintLayout。</p>
<h1 id="实现AutoHintLayout"><a href="#实现AutoHintLayout" class="headerlink" title="实现AutoHintLayout"></a>实现AutoHintLayout</h1><p>AutoHintLayout继承自LinearLayout，它需要至少有一个EditText子View，且对外提供一个设置hint的方法来设置hint值并实现切换的动画效果，动画相关的效果我们通过一个AutoHintHelper来集中处理，这样可以避免AutoHintLayout内堆砌太多逻辑。首先我们先定义AutoHintHelper对外提供的方法，具体实现后面详解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wulinpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoHintHelper</span> &#123;</span><br><span class="line">	<span class="comment">// AutoHintLayout，用于调用AutoHintLayout的invalidate方法触发刷新布局</span></span><br><span class="line">    <span class="keyword">private</span> View mView;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 绘制hint的区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">mHintBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">    <span class="comment">// 上一个hintText</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">mLastHintText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 当前要绘制的hintText</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">mHintText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">mHintTextSize</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> ColorStateList mHintTextColor;</span><br><span class="line">    <span class="keyword">private</span> Typeface mTypeFace;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mGravity</span> <span class="operator">=</span> Gravity.CENTER_VERTICAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Paint</span> <span class="variable">mPaint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutoHintHelper</span><span class="params">(View mView)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mView = mView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintText</span><span class="params">(String text, <span class="type">boolean</span> anim)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintTextSize</span><span class="params">(<span class="type">float</span> mHintTextSize)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintTextColor</span><span class="params">(ColorStateList mHintTextColor)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTypeFace</span><span class="params">(Typeface mTypeFace)</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span>[] state)</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGravity</span><span class="params">(<span class="type">int</span> mGravity)</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setHintBounds</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHint</span><span class="params">(<span class="type">boolean</span> showHint)</span> &#123;</span><br><span class="line">    	....</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * AutoHintLayout触发draw方法的时候调用此方法来绘制</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现AutoHintLayout-1"><a href="#实现AutoHintLayout-1" class="headerlink" title="实现AutoHintLayout"></a>实现AutoHintLayout</h3><p>首先我们要获得EditText绘制hint的相关属性，如颜色、字体、字体大小、Gravity等，在AutoHintLayout的addView方法中我们可以获取到EditText，并将对应的属性设置给AutoHintHelper，实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child, <span class="type">int</span> index, ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addView(child, index, params);</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> EditText) &#123;</span><br><span class="line">        setEditText((EditText) child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setEditText</span><span class="params">(EditText editText)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mEditText = editText;</span><br><span class="line">    mAutoHintHelper.setHintTextColor(mEditText.getHintTextColors());</span><br><span class="line">    mAutoHintHelper.setHintTextSize(mEditText.getTextSize());</span><br><span class="line">    mAutoHintHelper.setTypeFace(mEditText.getTypeface());</span><br><span class="line">    mAutoHintHelper.setGravity(mEditText.getGravity());</span><br><span class="line"></span><br><span class="line">    mEditText.addTextChangedListener(<span class="keyword">new</span> <span class="title class_">TextWatcher</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeTextChanged</span><span class="params">(CharSequence s, <span class="type">int</span> start, <span class="type">int</span> count, <span class="type">int</span> after)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTextChanged</span><span class="params">(CharSequence s, <span class="type">int</span> start, <span class="type">int</span> before, <span class="type">int</span> count)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterTextChanged</span><span class="params">(Editable s)</span> &#123;</span><br><span class="line">            <span class="comment">// 输入字符变化的时候判断是否需要显示hint</span></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(mEditText.getText().toString())) &#123;</span><br><span class="line">                mAutoHintHelper.showHint(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mAutoHintHelper.showHint(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们也给EditText设置了textChanged监听，在EditText输入字符的时候设置不显示hint，反之显示hint。然后我们需要在onLayout方法中给AutoHintHelper设置hint的绘制区域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onLayout(changed, l, t, r, b);</span><br><span class="line">    <span class="keyword">if</span> (mEditText != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">        <span class="comment">// 获取EditText在本View中的位置</span></span><br><span class="line">        setChildRect(mEditText, rect);</span><br><span class="line"></span><br><span class="line">        l = rect.left + mEditText.getCompoundPaddingLeft();</span><br><span class="line">        r = rect.right - mEditText.getCompoundPaddingRight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供AutoHintHelper hint的绘制区域</span></span><br><span class="line">        mAutoHintHelper.setHintBounds(</span><br><span class="line">                l, rect.top + mEditText.getCompoundPaddingTop(),</span><br><span class="line">                r, rect.bottom - mEditText.getCompoundPaddingBottom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setChildRect</span><span class="params">(View child, Rect out)</span> &#123;</span><br><span class="line">    out.set(<span class="number">0</span>, <span class="number">0</span>, child.getWidth(), child.getHeight());</span><br><span class="line">    <span class="comment">// 添加child在本布局中的offset到rect</span></span><br><span class="line">    offsetDescendantRectToMyCoords(child, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中setChildRect方法是获取到EditText在AutoHintlayout中的位置，然后加上四边的padding就可以了。<br>最后只要在draw方法中调用AutoHintHelper的draw方法将绘制逻辑交给AutoHintHelper就可以了，当然还需要对外提供一个setHint方法，实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.draw(canvas);</span><br><span class="line">    mAutoHintHelper.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHint</span><span class="params">(String text, <span class="type">boolean</span> anim)</span> &#123;</span><br><span class="line">    mAutoHintHelper.setHintText(text, anim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现AutoHintHelper"><a href="#实现AutoHintHelper" class="headerlink" title="实现AutoHintHelper"></a>实现AutoHintHelper</h3><p>主要的动画、绘制逻辑都由这个类实现，首先我们需要确定绘制hint的x和y坐标。EditText的Gravity不同和hint的长度不同会导致绘制hint的x、y坐标不一样（注意这里计算的x、y坐标指的是EditText正常显示hint的坐标，具体动画过程中的y偏移量在draw方法里添加），实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一个hint的绘制x坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> mLastDrawX;</span><br><span class="line"><span class="comment">// 当前hint的绘制x坐标</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">float</span> mDrawX;</span><br><span class="line">   <span class="comment">// hint的绘制y坐标(上一个和当前的都一样，具体的偏移在ondraw里面计算)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">float</span> mDrawY;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据gravity和paint的参数计算lastHint和当前hint的drawX以及drawY</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateDrawXY</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">float</span> <span class="variable">lastHintLength</span> <span class="operator">=</span> mPaint.measureText(mLastHintText, <span class="number">0</span>, mLastHintText.length());</span><br><span class="line">       <span class="type">float</span> <span class="variable">hintLength</span> <span class="operator">=</span> mPaint.measureText(mHintText, <span class="number">0</span>, mHintText.length());</span><br><span class="line">       <span class="comment">// 计算x值</span></span><br><span class="line">       <span class="keyword">switch</span> (mGravity &amp; GravityCompat.RELATIVE_HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">           <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">               mLastDrawX = mHintBounds.centerX() - (lastHintLength / <span class="number">2</span>);</span><br><span class="line">               mDrawX = mHintBounds.centerX() - (hintLength / <span class="number">2</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">               mLastDrawX = mHintBounds.right - lastHintLength;</span><br><span class="line">               mDrawX = mHintBounds.right - hintLength;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               mLastDrawX = mDrawX = mHintBounds.left;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 计算y值</span></span><br><span class="line">       <span class="keyword">switch</span> (mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123;</span><br><span class="line">           <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">               mDrawY = mHintBounds.bottom;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">               mDrawY = mHintBounds.top - mPaint.ascent();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="type">float</span> <span class="variable">textHeight</span> <span class="operator">=</span> mPaint.descent() - mPaint.ascent();</span><br><span class="line">               <span class="type">float</span> <span class="variable">textOffset</span> <span class="operator">=</span> (textHeight / <span class="number">2</span>) - mPaint.descent();</span><br><span class="line">               mDrawY = mHintBounds.centerY() + textOffset;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后就是设置一些绘制属性的方法了，每一次更改属性都需要重新计算一遍绘制的坐标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintTextSize</span><span class="params">(<span class="type">float</span> mHintTextSize)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mHintTextSize = mHintTextSize;</span><br><span class="line">    mPaint.setTextSize(mHintTextSize);</span><br><span class="line">    calculateDrawXY();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintTextColor</span><span class="params">(ColorStateList mHintTextColor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mHintTextColor = mHintTextColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTypeFace</span><span class="params">(Typeface mTypeFace)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mTypeFace = mTypeFace;</span><br><span class="line">    mPaint.setTypeface(mTypeFace);</span><br><span class="line">    calculateDrawXY();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span>[] state)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGravity</span><span class="params">(<span class="type">int</span> mGravity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mGravity = mGravity;</span><br><span class="line">    calculateDrawXY();</span><br><span class="line">    mView.invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setHintBounds</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;set bounds:&quot;</span> + left + <span class="string">&quot; &quot;</span> + top + <span class="string">&quot; &quot;</span> + right + <span class="string">&quot; &quot;</span> + bottom);</span><br><span class="line">    <span class="keyword">if</span> (!rectEquals(mHintBounds, left, top, right, bottom)) &#123;</span><br><span class="line">        mHintBounds.set(left, top, right, bottom);</span><br><span class="line">        onBoundsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onBoundsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">    calculateDrawXY();</span><br><span class="line">    mView.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来实现setHintText方法，每次外部调用这个方法首先更新hint和lastHint的值，然后开启一个ValueAnimator来开始动画，通过调用mView的invalidate方法触发draw方法绘制当前的hint</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ValueAnimator mAnimator;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">float</span> <span class="variable">mCurrentFraction</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mShowHint</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAnim</span><span class="params">()</span> &#123;</span><br><span class="line">       mAnimator = <span class="keyword">new</span> <span class="title class_">ValueAnimator</span>();</span><br><span class="line">       mAnimator.setDuration(<span class="number">300</span>);</span><br><span class="line">       mAnimator.setFloatValues(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">       mAnimator.addUpdateListener(<span class="keyword">new</span> <span class="title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> &#123;</span><br><span class="line">               mCurrentFraction = animation.getAnimatedFraction();</span><br><span class="line">               mView.invalidate();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHintText</span><span class="params">(String text, <span class="type">boolean</span> anim)</span> &#123;</span><br><span class="line">       mLastHintText = mHintText;</span><br><span class="line">       mHintText = text;</span><br><span class="line">       <span class="keyword">if</span> (mAnimator.isRunning()) &#123;</span><br><span class="line">           mAnimator.cancel();</span><br><span class="line">       &#125;</span><br><span class="line">       calculateDrawXY();</span><br><span class="line">       <span class="keyword">if</span> (anim) &#123;</span><br><span class="line">           mCurrentFraction = <span class="number">0f</span>;</span><br><span class="line">           mAnimator.start();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mCurrentFraction = <span class="number">1f</span>;</span><br><span class="line">           mView.invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHint</span><span class="params">(<span class="type">boolean</span> showHint)</span> &#123;</span><br><span class="line">       mShowHint = showHint;</span><br><span class="line">       mView.invalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先需要将运行中的动画取消，然后重新计算绘制坐标，如果不需要动画则直接设置mCurrentFraction为1，draw的时候将直接绘制当前的hint，不做任何动画，反之开启动画。<br>最后实现最关键的draw方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mShowHint) &#123;</span><br><span class="line">        <span class="comment">// draw empty</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaint.setColor(state == <span class="literal">null</span>? mHintTextColor.getDefaultColor(): mHintTextColor.getColorForState(state, <span class="number">0</span>));</span><br><span class="line">    <span class="type">float</span> <span class="variable">boundsHeight</span> <span class="operator">=</span> mHintBounds.bottom - mHintBounds.top;</span><br><span class="line">    <span class="type">float</span> <span class="variable">offsetY</span> <span class="operator">=</span> boundsHeight * mCurrentFraction;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// draw last hint with curr fraction</span></span><br><span class="line">    canvas.drawText(mLastHintText, <span class="number">0</span>, mLastHintText.length(), mLastDrawX, mDrawY - offsetY, mPaint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw curr hint with curr fraction</span></span><br><span class="line">    canvas.drawText(mHintText, <span class="number">0</span>, mHintText.length(), mDrawX, boundsHeight + mDrawY - offsetY, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过mCurrentFraction计算出当前的y偏移值，也就是lastHint应该向上滚动的距离，绘制lastHint的时候将mDrawY减去offset就可以了。绘制当前hint的时候需要在lastHint的基础上加上boundsHeight，也就是说新的hint在老的hint下方boundsHeight距离，boundsHeight就是绘制hint区域的高度。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>到此就基本实现了hint滚动播放的效果，但是仔细想想，hint的动画只会有这么一种吗？如果我需要别的动画效果呢？我是不是需要重新写对应的XXHintLayout类？这里就要考虑到扩展性，无论什么动画，只要我们提供hint绘制区域、绘制的paint、动画播放进度等信息就可以实现，所以这里抽象出一个接口IAutoHintDrawer来实现具体的绘制方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wulinpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: hint动画的具体绘制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAutoHintDrawer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Rect drawBounds, <span class="type">float</span> lastDrawX, <span class="type">float</span> drawX, <span class="type">float</span> drawY, <span class="type">float</span> fraction, String lastHint, String currHint, Canvas canvas, Paint paint)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在AutoHintHelper的draw方法中调用IAutoHintDrawer的draw方法来实现，而IAutoHintDrawer的实例由具体的业务方实现然后传入，具体的实现就不赘述了，本项目的代码已经上传到<a href="https://github.com/1014277960/AutoHintLayout">Github</a>，欢迎交流。</p>
]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title>使用位运算实现加法</title>
    <url>/2017/03/31/%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>求两个整数之和，要求不使用+、-、*、&#x2F;四则运算符号，那么只能想到用位运算了，其实二进制和十进制的运算是很相似的，都是每一位相加，多出来的进位。以7和3为例，二进制分别是111和101，假设不考虑进位，那么结果就是010，也就是111^101，同时也可以算得进位就是(111&amp;101)&lt;&lt;1，最后就变成了这两个数相加，重复之前的步骤，直到进位是0，就完成了加法。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">111</span>, num2 = <span class="number">899</span>;</span><br><span class="line">	<span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 让num2变成进位，num1就是不考虑进位的值，一直到num2为0，num1就是结果</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num1;</span><br><span class="line">           num1 = num1 ^ num2;</span><br><span class="line">           num2 = (temp &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">           System.out.println(<span class="string">&quot;num1:&quot;</span> + num1 + <span class="string">&quot;num2&quot;</span> + num2);</span><br><span class="line">       &#125;</span><br><span class="line">	System.out.println(num1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>关于Hprof的方方面面</title>
    <url>/2019/09/18/%E5%85%B3%E4%BA%8EHprof%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Hprof概述"><a href="#Hprof概述" class="headerlink" title="Hprof概述"></a>Hprof概述</h1><p>hprof最初是由J2SE支持的一种二进制堆转储格式，hprof文件保存了当前java堆上所有的内存使用信息，能够完整的反映虚拟机当前的内存状态。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>详细的Hprof标准格式可以参考<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF Agent</a>，本节将根据该文档简单介绍Hprof格式。<br><img src="/images/hprof0.jpg"><br>Hprof文件由FixedHead和一系列的Record组成，Record包含字符串信息、类信息、栈信息、GcRoot信息、对象信息。每个Record都是由1个字节的Tag、4个字节的Time、4个字节的Length和Body组成，Tag表示该Record的类型，Body部分为该Record的内容，长度为Length。</p>
<table>
<thead>
<tr>
<th align="left">1</th>
<th align="left">4</th>
<th align="left">4</th>
<th>Length</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tag</td>
<td align="left">time</td>
<td align="left">length</td>
<td>body</td>
</tr>
</tbody></table>
<p>不同类型Record的body部分格式不同，包含的信息也不同，接下来分析一些比较重要的Record。</p>
<h2 id="FixedHead"><a href="#FixedHead" class="headerlink" title="FixedHead"></a>FixedHead</h2><p>Hprof首先包含了文件的版本描述信息及版本号，一般固定为”JAVA PROFILE 1.0.2”，以&#x2F;0结尾。随后是长度为4字节的id size，最后是长度为8个字节的时间戳。Hprof文件中几乎所有类型的Record都有用到id，这里的id size指的就是这个id的长度，用来告诉我们需要读取多少字节的内容来获取id。</p>
<table>
<thead>
<tr>
<th align="left">19</th>
<th align="left">4</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“JAVA PROFILE 1.0.2&#x2F;0”</td>
<td align="left">ID size</td>
<td>时间戳</td>
</tr>
</tbody></table>
<h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><p>FixedHead后面就是一系列的String Record，Tag为0x01，每个String Record保存一个字符串和该字符串对应的id，后续通过该id来查询字符串。这里的String存储了后面将用到字符串，包括类名，常量等。String Record的body首先包含一个id，由于body部分长度为Length，所以字符串内容为后续(Length-idSize)个字节。</p>
<h2 id="LOAD-CLASS"><a href="#LOAD-CLASS" class="headerlink" title="LOAD CLASS"></a>LOAD CLASS</h2><p>LOAD CLASS Record记录了简单的类信息，Tag为0x02。body部分包含了4个字节长的序列号、类id、4个字节的栈序列号、类名id，可以通过类名id从上述的一系列String Record中找到当前类的类名。</p>
<h2 id="HEAP-DUMP-HEAP-DUMP-SEGMENT"><a href="#HEAP-DUMP-HEAP-DUMP-SEGMENT" class="headerlink" title="HEAP DUMP&#x2F;HEAP DUMP SEGMENT"></a>HEAP DUMP&#x2F;HEAP DUMP SEGMENT</h2><p>这两个Record主要是包含GcRoot信息、对象信息、详细的类信息，在解析Hprof的时候这两个Record对我们来说作用是一样的(不知道为啥分成两个Record？)，接下来就以HEAP DUMP为例。<br>HEAP DUMP是一个非常大的Record，内部包含了一系列的SubRecord，每个SubRecord均以一个字节的SubTag开头，接下来一一解析这些SubRecord。</p>
<h3 id="ROOT-XXX"><a href="#ROOT-XXX" class="headerlink" title="ROOT XXX"></a>ROOT XXX</h3><p>首先是一系列的GCRoot，SubTag范围是 0x01到0x08 和 0xFF 这9个，每个GCRoot的Record均有一个Object Id，用来表示该GCRoot对应的Object，其余的部分参考文档。</p>
<h3 id="CLASS-DUMP"><a href="#CLASS-DUMP" class="headerlink" title="CLASS DUMP"></a>CLASS DUMP</h3><p>CLASS DUMP包含详细的类信息，SubTag为0x20，接下来按照顺序来解析body部分的内容</p>
<ul>
<li>class object ID：与上面的LOAD CLASS中的类id一致，所以可以通过之前的LOAD CLASS Record来得到当前类的类名</li>
<li>stack trace serial number：4个字节的栈序列号</li>
<li>super class object ID：父类的类id</li>
<li>class loader object ID：类加载器的Object id</li>
<li>signers object ID：暂不清楚作用</li>
<li>protection domain object ID：暂不清楚作用</li>
<li>reserved：两个reserved Id，暂无用处</li>
<li>instance size (in bytes)：四个字节的类实例占用的大小</li>
<li>constant pool：2个字节的常量池数量n，接下来包含n个常量，每一个常量包含两个字节的index、1个字节的类型信息、x个字节的常量值。其中x根据该常量的类型决定，Object类型的值为一个Object id，具体参考文档。</li>
<li>静态变量信息：和constant pool十分类似，唯一区别是2个字节的index替换为变量Name id，用来表示该静态变量的变量名</li>
<li>成员变量信息：首先也是2个字节的数量n，接下来是n个成员变量，每一个成员变量包含一个Name id和1个字节的变量类型</li>
</ul>
<p>综上，CLASS DUMP包含了类的类加载器、父类、实例大小、常量池、静态变量、成员变量的信息。</p>
<h3 id="INSTANCE-DUMP"><a href="#INSTANCE-DUMP" class="headerlink" title="INSTANCE DUMP"></a>INSTANCE DUMP</h3><p>NSTANCE DUMP包含类对象的信息，SubTag为0x21。包含了一个Object id、4个字节的栈序列号、类id、4个字节的长度n、成员变量信息。其中长度n表示后面的成员变量信息占用了多少字节。成员变量信息是该对象所有成员变量的值组合在一起(包括父类的成员变量)，读取方式如下：</p>
<ul>
<li>从上述CLASS DUMP中获得当前类的成员变量信息，按照该信息顺序依次读取变量值(比如Char读取两个字节的长度，Object读取idSize的长度)</li>
<li>获得父类的成员变量信息，重复上述操作，直至没有父类为止</li>
</ul>
<h3 id="OBJECT-ARRAY-DUMP-和-PRIMITIVE-ARRAY-DUMP"><a href="#OBJECT-ARRAY-DUMP-和-PRIMITIVE-ARRAY-DUMP" class="headerlink" title="OBJECT ARRAY DUMP 和 PRIMITIVE ARRAY DUMP"></a>OBJECT ARRAY DUMP 和 PRIMITIVE ARRAY DUMP</h3><p>这两个SubRecord存储数组对象的信息，比较简单，可以参考文档自行分析。</p>
<h1 id="Android中的hprof"><a href="#Android中的hprof" class="headerlink" title="Android中的hprof"></a>Android中的hprof</h1><p>在Android设备上，我们可以通过两种方式生成当前进程的hprof文件</p>
<ul>
<li>通过调用<code>Debug.dumpHprofData(String filePath)</code>方法来生成hprof文件</li>
<li>通过执行shell命令<code>adb shell am dumpheap pid /data/local/tmp/x.hprof</code>来生成指定进程的hprof文件到目标目录</li>
</ul>
<p>然而Android平台上的hprof文件和标准Java的hprof定义有一些区别，主要是版本号不一样，而且增加了一些特殊Tag，在art&#x2F;runtime&#x2F;hprof&#x2F;hprof.cc中有如下定义<br><img src="/images/hprof1.png"><br>可以看出Android增加了额外的9个HeapTag，其中比较重要的是HPROF_HEAP_DUMP_INFO。Android上将java堆分为Heap-App、Heap-Image、Heap-Zygote三块，这个Tag的作用是切换当前的堆，该Tag后面紧跟着一个4个字节的堆id和一个堆名称id。比如出现一个HPROF_HEAP_DUMP_INFO Record，且该Record表示Heap-Image，那么表示后续所有Record中的类、对象、GCRoot对象均在Heap-Image中存储，直到下一个HPROF_HEAP_DUMP_INFO出现为止。<br>Android平台上针对hprof的改动会导致MAT等标准hprof分析工具无法解析，因此我们需要使用AndroidSDK提供的hprof-conv工具将hprof转换为标准hprof，该工具在sdk&#x2F;platform-tools下，使用方式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 其中-z表示忽略除app堆以外的堆(Image/Zygote)</span><br><span class="line">hprof-conv [-z] infile outfile</span><br></pre></td></tr></table></figure>
<p>hprof-conv具体做了什么呢？接下来通过hprof-conv的源码来分析</p>
<h2 id="修改版本信息"><a href="#修改版本信息" class="headerlink" title="修改版本信息"></a>修改版本信息</h2><p><img src="/images/hprof2.png"><br>首先判断当前hprof文件版本号是否是”JAVA PROFILE 1.0.3”，如果不是则报错，反之将版本信息从”JAVA PROFILE 1.0.3”降为”JAVA PROFILE 1.0.2”。</p>
<h2 id="修改HeapTag信息"><a href="#修改HeapTag信息" class="headerlink" title="修改HeapTag信息"></a>修改HeapTag信息</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> subType = buf[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> justCopy = TRUE;</span><br><span class="line">        <span class="type">int</span> subLen;</span><br><span class="line">        <span class="built_in">DBUG</span>(<span class="string">&quot;--- 0x%02x  &quot;</span>, subType);</span><br><span class="line">        <span class="keyword">switch</span> (subType) &#123;</span><br><span class="line">        <span class="comment">/* 1.0.2 types */</span></span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_UNKNOWN:</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_JNI_GLOBAL:</span><br><span class="line">            subLen = kIdentSize * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_JNI_LOCAL:</span><br><span class="line">            subLen = kIdentSize + <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_JAVA_FRAME:</span><br><span class="line">            subLen = kIdentSize + <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_NATIVE_STACK:</span><br><span class="line">            subLen = kIdentSize + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_STICKY_CLASS:</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_THREAD_BLOCK:</span><br><span class="line">            subLen = kIdentSize + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_MONITOR_USED:</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_THREAD_OBJECT:</span><br><span class="line">            subLen = kIdentSize + <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_CLASS_DUMP:</span><br><span class="line">            subLen = <span class="built_in">computeClassDumpLen</span>(buf<span class="number">+1</span>, len<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_INSTANCE_DUMP:</span><br><span class="line">            subLen = <span class="built_in">computeInstanceDumpLen</span>(buf<span class="number">+1</span>, len<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// 如果当前堆被忽略(带了-z参数)则丢弃该tag</span></span><br><span class="line">            <span class="keyword">if</span> (heapIgnore) &#123;</span><br><span class="line">                justCopy = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_OBJECT_ARRAY_DUMP:</span><br><span class="line">            subLen = <span class="built_in">computeObjectArrayDumpLen</span>(buf<span class="number">+1</span>, len<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// 如果当前堆被忽略(带了-z参数)则丢弃该tag</span></span><br><span class="line">            <span class="keyword">if</span> (heapIgnore) &#123;</span><br><span class="line">                justCopy = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_PRIMITIVE_ARRAY_DUMP:</span><br><span class="line">            subLen = <span class="built_in">computePrimitiveArrayDumpLen</span>(buf<span class="number">+1</span>, len<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// 如果当前堆被忽略(带了-z参数)则丢弃该tag</span></span><br><span class="line">            <span class="keyword">if</span> (heapIgnore) &#123;</span><br><span class="line">                justCopy = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* these were added for Android in 1.0.3 */</span></span><br><span class="line">        <span class="comment">// 以下为Android新加HeapTag</span></span><br><span class="line">        <span class="keyword">case</span> HPROF_HEAP_DUMP_INFO:</span><br><span class="line">        	<span class="comment">// 如果带了-z参数则丢弃HPROF_HEAP_ZYGOTE和HPROF_HEAP_IMAGE堆的数据</span></span><br><span class="line">            heapType = <span class="built_in">get4BE</span>(buf<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; kFlagAppOnly) != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (heapType == HPROF_HEAP_ZYGOTE || heapType == HPROF_HEAP_IMAGE)) &#123;</span><br><span class="line">                heapIgnore = TRUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heapIgnore = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            justCopy = FALSE;</span><br><span class="line">            subLen = kIdentSize + <span class="number">4</span>;</span><br><span class="line">            <span class="comment">// no 1.0.2 equivalent for this</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_INTERNED_STRING:</span><br><span class="line">        	<span class="comment">// 将tag名改为HPROF_ROOT_UNKNOWN</span></span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_FINALIZING:</span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_DEBUGGER:</span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_REFERENCE_CLEANUP:</span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_VM_INTERNAL:</span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_ROOT_JNI_MONITOR:</span><br><span class="line">            <span class="comment">/* keep the ident, drop the next 8 bytes */</span></span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            justCopy = FALSE;</span><br><span class="line">            <span class="built_in">ebAddData</span>(pOutBuf, buf, <span class="number">1</span> + kIdentSize);</span><br><span class="line">            subLen = kIdentSize + <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_UNREACHABLE:</span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_ROOT_UNKNOWN;</span><br><span class="line">            subLen = kIdentSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HPROF_PRIMITIVE_ARRAY_NODATA_DUMP:</span><br><span class="line">        	<span class="comment">// 将空array tag改为array tag且将长度设置为0</span></span><br><span class="line">            buf[<span class="number">0</span>] = HPROF_PRIMITIVE_ARRAY_DUMP;</span><br><span class="line">            buf[<span class="number">5</span>] = buf[<span class="number">6</span>] = buf[<span class="number">7</span>] = buf[<span class="number">8</span>] = <span class="number">0</span>;  <span class="comment">/* set array len to 0 */</span></span><br><span class="line">            subLen = kIdentSize + <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* shouldn&#x27;t get here */</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR: unexpected subtype 0x%02x at offset %zu\n&quot;</span>,</span><br><span class="line">                subType, (<span class="type">size_t</span>) (buf - origBuf));</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (justCopy) &#123;</span><br><span class="line">            <span class="comment">/* copy source data */</span></span><br><span class="line">            <span class="built_in">DBUG</span>(<span class="string">&quot;(%d)\n&quot;</span>, <span class="number">1</span> + subLen);</span><br><span class="line">            <span class="built_in">ebAddData</span>(pOutBuf, buf, <span class="number">1</span> + subLen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* other data has been written, or the sub-record omitted */</span></span><br><span class="line">            <span class="built_in">DBUG</span>(<span class="string">&quot;(adv %d)\n&quot;</span>, <span class="number">1</span> + subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* advance to next entry */</span></span><br><span class="line">        buf += <span class="number">1</span> + subLen;</span><br><span class="line">        len -= <span class="number">1</span> + subLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要做了4件事</p>
<ol>
<li><p align="left">针对标准hprof的HeapTag除了HPROF_INSTANCE_DUMP、HPROF_OBJECT_ARRAY_DUMP、HPROF_PRIMITIVE_ARRAY_DUMP照常写入，不做更改</p></li>
<li><p align="left">Android新增的Tag除了HPROF_HEAP_DUMP_INFO、HPROF_PRIMITIVE_ARRAY_NODATA_DUMP，都将Tag改为HPROF_ROOT_UNKNOWN写入，同时将HPROF_PRIMITIVE_ARRAY_NODATA_DUMP改为长度为0的HPROF_PRIMITIVE_ARRAY_DUMP</p></li>
<li><p align="left">丢弃HPROF_HEAP_DUMP_INFO Tag不写入，同时根据命令是否携带-z参数来判断当前堆是否需要写入，更新heapIgnore标志位</p></li>
<li><p align="left">针对HPROF_INSTANCE_DUMP、HPROF_OBJECT_ARRAY_DUMP、HPROF_PRIMITIVE_ARRAY_DUMP，如果当前堆不需要写入，即heapIgnore = TRUE，则丢弃当前Record信息</p></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://androidxref.com/8.1.0_r33/xref/art/runtime/hprof/hprof.cc">hprof.cc</a></li>
<li><a href="https://android.googlesource.com/platform/dalvik/+/refs/heads/android10-release/tools/hprof-conv/HprofConv.c">HprofConv.c</a></li>
</ul>
]]></content>
      <categories>
        <category>内存</category>
      </categories>
  </entry>
  <entry>
    <title>变态跳台阶</title>
    <url>/2016/09/21/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>令dp[i]表示跳i级台阶不同跳法的数量，假设最后一跳是k阶，那么就有dp[i -k]种跳法，和跳i－k是一样的跳法，k可以取1-i，所以所有方法就是<br>dp[i] &#x3D; dp[1] + dp[2]+…+dp[i-1] + 1<br>最后的1就是直接跳到i的情况</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">JumpFloorII</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != target; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>回文字符串问题</title>
    <url>/2016/11/09/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个字符串，问是否能通过添加一个字母将其变为回文串。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有两个思路。</p>
<ol>
<li><p>如果加一个可以形成回文，那么减去一个也必定可以。可以通过遍历字符串减去一个字符判断是否回文，如果有存在那就输出YES，反之输出NO。</p>
</li>
<li><p>如果字符串首位不一样，那么加上的字符要么是在末尾加上第一个字符，要么是在头部加上末位的字符，判断两种情况是否存在回文串就可以；如果首尾一样，那么就可以略去首尾，继续用这种方法判断。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>字节码插桩实践</title>
    <url>/2020/01/30/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Gradle-Plugin"><a href="#Gradle-Plugin" class="headerlink" title="Gradle Plugin"></a>Gradle Plugin</h1><p>首先我们需要创建一个插件来注册我们的Transform，步骤如下</p>
<h2 id="创建module"><a href="#创建module" class="headerlink" title="创建module"></a>创建module</h2><p>Android Module项目,类型选择Android Library,将Module里的内容删除，只保留build.gradle文件和src&#x2F;main目录，同时移除build.gradle文件里的内容</p>
<h2 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h2><p>gradle插件可以使用java&#x2F;groovy&#x2F;kotlin实现，我们选择java。修改build.gradle为如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;java&#x27;</span><br><span class="line">apply plugin: &#x27;maven&#x27;</span><br><span class="line"></span><br><span class="line">dependencies&#123;</span><br><span class="line">    // gradle sdk</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    // groovy sdk</span><br><span class="line">    compile localGroovy()</span><br><span class="line">    compile &#x27;com.android.tools.build:gradle:1.5.0&#x27;</span><br><span class="line"></span><br><span class="line">    implementation&#x27;com.android.tools.build:gradle-api:3.1.4&#x27;</span><br><span class="line">    implementation&#x27;com.android.tools.build:gradle-core:1.5.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories&#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建插件类"><a href="#创建插件类" class="headerlink" title="创建插件类"></a>创建插件类</h2><p>在main目录下建立java目录，然后新建package，最后创建类PluginImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginImpl</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Project project)</span>&#123;</span><br><span class="line">        <span class="comment">// 执行plugin的入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义插件"><a href="#定义插件" class="headerlink" title="定义插件"></a>定义插件</h2><p>定义插件名称.在resources&#x2F;META-INF&#x2F;gradle-plugins目录下新建一个properties文件，注意该文件的命名就是你使用插件的名字，比如tt.properties，那么你在其他build.gradle文件中使用自定义的插件时候则需写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;tt&#x27;</span><br></pre></td></tr></table></figure>
<p>tt.properties文件内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation-class=com.wulinpeng.PluginImpl</span><br></pre></td></tr></table></figure>
<p>表明该Plugin的实现类</p>
<h2 id="插件发布到本地Maven仓库"><a href="#插件发布到本地Maven仓库" class="headerlink" title="插件发布到本地Maven仓库"></a>插件发布到本地Maven仓库</h2><p>在我们定义的module下的build.gralde中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            pom.groupId = &#x27;com.wulinpeng&#x27;</span><br><span class="line">            pom.artifactId = &#x27;tt&#x27;</span><br><span class="line">            pom.version = 1.0</span><br><span class="line">            // maven本地仓库的目录</span><br><span class="line">            repository(url: uri(&#x27;../TTPlugin&#x27;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行uploadArchives后项目下多出一个TTPluginn目录，里面存着这个gradle插件。</p>
<h2 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h2><p>要想使用插件我们需要在项目根目录下的gradle.build的文件中加入如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        // maven插件目录</span><br><span class="line">        maven&#123;</span><br><span class="line">            url uri(&#x27;TTPlugin&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.android.tools.build:gradle:2.1.0&#x27;</span><br><span class="line">        // 使用自定义插件</span><br><span class="line">        classpath &#x27;com.wulinpeng:tt:1.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在app下的build.gradle中添加<code>apply plugin: &#39;tt&#39;</code>就可以了</p>
<h1 id="Transform-API"><a href="#Transform-API" class="headerlink" title="Transform API"></a>Transform API</h1><h2 id="在插件中注册Transform"><a href="#在插件中注册Transform" class="headerlink" title="在插件中注册Transform"></a>在插件中注册Transform</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PluginImpl implements Plugin&lt;Project&gt;&#123;</span><br><span class="line"></span><br><span class="line">    public void apply(Project project)&#123;</span><br><span class="line">        project.getExtensions().findByType(AppExtension.class).registerTransform(new TTTransform());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JarInput-DirectoryInput处理"><a href="#JarInput-DirectoryInput处理" class="headerlink" title="JarInput &amp; DirectoryInput处理"></a>JarInput &amp; DirectoryInput处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author：wulinpeng</span><br><span class="line"> * date：2020-01-25 22:48</span><br><span class="line"> * desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void triggerScan(TransformInvocation transformInvocation, BytecodeAdapter adapter) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        //消费型输入，可以从中获取jar包和class文件夹路径。需要输出给下一个任务</span><br><span class="line">        Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();</span><br><span class="line">        //引用型输入，无需输出。</span><br><span class="line">        Collection&lt;TransformInput&gt; referencedInputs = transformInvocation.getReferencedInputs();</span><br><span class="line">        //OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null</span><br><span class="line">        TransformOutputProvider outputProvider = transformInvocation.getOutputProvider();</span><br><span class="line">        for (TransformInput input : inputs) &#123;</span><br><span class="line">            for (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(</span><br><span class="line">                        jarInput.getFile().getAbsolutePath(),</span><br><span class="line">                        jarInput.getContentTypes(),</span><br><span class="line">                        jarInput.getScopes(),</span><br><span class="line">                        Format.JAR);</span><br><span class="line">                dealJar(transformInvocation.getContext(), jarInput.getFile(), adapter);</span><br><span class="line">                FileUtils.copyFile(jarInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">            for (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(directoryInput.getName(),</span><br><span class="line">                        directoryInput.getContentTypes(), directoryInput.getScopes(),</span><br><span class="line">                        Format.DIRECTORY);</span><br><span class="line">                //将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了</span><br><span class="line">                FileUtils.getAllFiles(directoryInput.getFile()).filter(new Predicate&lt;File&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean apply(@Nullable File input) &#123;</span><br><span class="line">                        return input.getName().endsWith(SdkConstants.DOT_CLASS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).forEach(new Consumer&lt;File&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void accept(File file) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // 修改字节码</span><br><span class="line">                            byte[] classCode = adapter.acceptBytecode(IOUtils.toByteArray(new FileInputStream(file)));</span><br><span class="line">                            FileOutputStream outputStream = new FileOutputStream(file);</span><br><span class="line">                            outputStream.write(classCode);</span><br><span class="line">                            outputStream.close();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                // 将file copy到目标目录</span><br><span class="line">                try &#123;</span><br><span class="line">                    FileUtils.copyDirectory(directoryInput.getFile(), dest);</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 做一次input 到 dest的copy</span><br><span class="line">     * @param transformInvocation</span><br><span class="line">     * @throws TransformException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public void flulsh(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();</span><br><span class="line">        TransformOutputProvider outputProvider = transformInvocation.getOutputProvider();</span><br><span class="line">        for (TransformInput input : inputs) &#123;</span><br><span class="line">            for (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(</span><br><span class="line">                        jarInput.getFile().getAbsolutePath(),</span><br><span class="line">                        jarInput.getContentTypes(),</span><br><span class="line">                        jarInput.getScopes(),</span><br><span class="line">                        Format.JAR);</span><br><span class="line">                FileUtils.copyFile(jarInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">            for (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(directoryInput.getName(),</span><br><span class="line">                        directoryInput.getContentTypes(), directoryInput.getScopes(),</span><br><span class="line">                        Format.DIRECTORY);</span><br><span class="line">                // 将file copy到目标目录</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.getFile(), dest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void dealJar(Context context, File jarfile, BytecodeAdapter adapter) &#123;</span><br><span class="line">        File modifyFile = modifyJar(jarfile, context.getTemporaryDir(), true, adapter);</span><br><span class="line">        if (jarfile.exists()) &#123;</span><br><span class="line">            jarfile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileUtils.copyFile(modifyFile, jarfile);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static File modifyJar(File jarFile, File tempDir, boolean nameHex, BytecodeAdapter adapter) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JarFile file = new JarFile(jarFile);</span><br><span class="line">            String hexName = &quot;&quot;;</span><br><span class="line">            if (nameHex) &#123;</span><br><span class="line">                hexName = DigestUtils.md5Hex(jarFile.getAbsolutePath()).substring(0, 8);</span><br><span class="line">            &#125;</span><br><span class="line">            File outputJar = new File(tempDir, hexName + jarFile.getName());</span><br><span class="line">            JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(outputJar));</span><br><span class="line">            Enumeration enumeration = file.entries();</span><br><span class="line">            while (enumeration.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry = (JarEntry) enumeration.nextElement();</span><br><span class="line">                InputStream inputStream = file.getInputStream(jarEntry);</span><br><span class="line">                String entryName = jarEntry.getName();</span><br><span class="line">                ZipEntry zipEntry = new ZipEntry(entryName);</span><br><span class="line">                jarOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                byte[] modifiedClassBytes = null;</span><br><span class="line">                byte[] sourceClassBytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">                if (shouldModifyClass(entryName)) &#123;</span><br><span class="line">                    modifiedClassBytes = adapter.acceptBytecode(sourceClassBytes);</span><br><span class="line">                    jarOutputStream.write(modifiedClassBytes);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    jarOutputStream.write(sourceClassBytes);</span><br><span class="line">                &#125;</span><br><span class="line">                jarOutputStream.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            jarOutputStream.close();</span><br><span class="line">            file.close();</span><br><span class="line">            return outputJar;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean shouldModifyClass(String entryName) &#123;</span><br><span class="line">        if (!entryName.endsWith(&quot;.class&quot;)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (entryName.startsWith(&quot;android&quot;) || entryName.startsWith(&quot;java&quot;) || entryName.startsWith(&quot;kotlin&quot;)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface BytecodeAdapter &#123;</span><br><span class="line">        byte[] acceptBytecode(byte[] bytecode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h1>]]></content>
      <categories>
        <category>字节码</category>
      </categories>
  </entry>
  <entry>
    <title>字节码层面看switch</title>
    <url>/2020/08/10/%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8Bswitch/</url>
    <content><![CDATA[<h1 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h1><p><code>switch</code>支持char、byte、short、int、Character、Byte、Short、Integer、String、Enum十种类型，其中对Emun与String的支持是在JDK1.5和JDK1.7的时候增加的，同时switch并不支持long、double、float。</p>
<h1 id="基础类型的Switch"><a href="#基础类型的Switch" class="headerlink" title="基础类型的Switch"></a>基础类型的Switch</h1><p><code>switch</code>最终会被编译为<code>tableswitch</code>和<code>lookupswitch</code>两个指令，且<code>tableswitch</code>和<code>lookupswitch</code>仅支持int数据，这也就是为什么<code>switch</code>不支持long、double、float的原因，因为这三种类型无法转换为int。</p>
<h2 id="tableswitch"><a href="#tableswitch" class="headerlink" title="tableswitch"></a>tableswitch</h2><p>当<code>switch</code>内的case序列能被表示为一个表中的索引值时，则使用<code>tableswitch</code>。即case的值是连续的，那么就可以使用<code>tableswitch</code>。底层实现是维护一个int数组，下标是case值，数组的值则是转跳的偏移量，这样做效率非常高，时间复杂度是O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void intSwitch() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            System.out.println(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            System.out.println(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// access flags 0x2</span><br><span class="line">private intSwitch()V</span><br><span class="line"> L0</span><br><span class="line">  ICONST_1</span><br><span class="line">  ISTORE 1</span><br><span class="line"> L1</span><br><span class="line">  ILOAD 1</span><br><span class="line">  TABLESWITCH</span><br><span class="line">    1: L2 // L2-L5为具体的执行逻辑</span><br><span class="line">    2: L3</span><br><span class="line">    3: L4</span><br><span class="line">    default: L5</span><br></pre></td></tr></table></figure>
<p>还有一种情况，当case序列并不是连续分布，但是也并不是很稀疏，编译器会通过补上中间空缺的值将它变成一个连续的序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void intSwitch() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 101:</span><br><span class="line">            System.out.println(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 102:</span><br><span class="line">            System.out.println(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">            break;</span><br><span class="line">        case 104:</span><br><span class="line">            System.out.println(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private intSwitch()V</span><br><span class="line"> L0</span><br><span class="line">  ICONST_1</span><br><span class="line">  ISTORE 1</span><br><span class="line"> L1</span><br><span class="line">  ILOAD 1</span><br><span class="line">  TABLESWITCH</span><br><span class="line">    101: L2</span><br><span class="line">    102: L3</span><br><span class="line">    103: L5 // 编译器补上了case = 10，跳转逻辑和default相同</span><br><span class="line">    104: L4</span><br><span class="line">    default: L5</span><br></pre></td></tr></table></figure>
<h2 id="lookupswitch"><a href="#lookupswitch" class="headerlink" title="lookupswitch"></a>lookupswitch</h2><p>当<code>switch</code>内的case序列分布很稀疏，强行使用<code>tableswitch</code>会导致序列过长占用大量空间，这时候会使用<code>lookupswitch</code>。<code>lookupswitch</code>会将case的值和转跳的偏移量保存在一个Map里，当<code>lookupswitch</code>被执行的时候，将目标值和这个Map里的keys逐一对比找到符合的偏移量跳转，没有找到则使用default。当然编译器会对keys进行排序，所以搜索方式应该是通过二分(猜的)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void intSwitch() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 101:</span><br><span class="line">            System.out.println(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 1000:</span><br><span class="line">            System.out.println(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private intSwitch()V</span><br><span class="line">   L0</span><br><span class="line">    ICONST_1</span><br><span class="line">    ISTORE 1</span><br><span class="line">   L1</span><br><span class="line">    ILOAD 1</span><br><span class="line">    LOOKUPSWITCH</span><br><span class="line">      1: L2</span><br><span class="line">      101: L3</span><br><span class="line">      1000: L4</span><br><span class="line">      default: L5</span><br></pre></td></tr></table></figure>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>这部分的逻辑可以看javac的源码<a href="http://hg.openjdk.java.net/jdk8/jdk8/langtools/file/1ff9d5118aae/src/share/classes/com/sun/tools/javac/jvm/Gen.java">Gen.java</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Determine whether to issue a tableswitch or a lookupswitch</span><br><span class="line">// instruction.</span><br><span class="line">long table_space_cost = 4 + ((long) hi - lo + 1); // words</span><br><span class="line">long table_time_cost = 3; // comparisons</span><br><span class="line">long lookup_space_cost = 3 + 2 * (long) nlabels;</span><br><span class="line">long lookup_time_cost = nlabels;</span><br><span class="line">int opcode =</span><br><span class="line">    nlabels &gt; 0 &amp;&amp;</span><br><span class="line">    table_space_cost + 3 * table_time_cost &lt;=</span><br><span class="line">    lookup_space_cost + 3 * lookup_time_cost</span><br><span class="line">    ?</span><br><span class="line">    tableswitch : lookupswitch;</span><br></pre></td></tr></table></figure>
<p>大概就是空间和时间上的权衡</p>
<h1 id="String的Switch"><a href="#String的Switch" class="headerlink" title="String的Switch"></a>String的Switch</h1><p>由于<code>tableswitch</code>和<code>lookupswitch</code>只支持int，所以String的<code>switch</code>逻辑本质还是int的switch。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void stringSwitch() &#123;</span><br><span class="line">    String a = &quot;&quot;;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case &quot;AA&quot;:</span><br><span class="line">            System.out.println(&quot;Test1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;BB&quot;:</span><br><span class="line">            System.out.println(&quot;Test2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Test3&quot;:</span><br><span class="line">            System.out.println(&quot;Test3&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // access flags 0x2</span><br><span class="line">  private stringSwitch()V</span><br><span class="line">   L0</span><br><span class="line">    LDC &quot;&quot;</span><br><span class="line">    ASTORE 1</span><br><span class="line">   L1</span><br><span class="line">    ALOAD 1</span><br><span class="line">    ASTORE 2</span><br><span class="line">    ICONST_M1</span><br><span class="line">    ISTORE 3</span><br><span class="line">    ALOAD 2</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.hashCode ()I</span><br><span class="line">    LOOKUPSWITCH</span><br><span class="line">      2080: L2</span><br><span class="line">      2112: L3</span><br><span class="line">      80698817: L4</span><br><span class="line">      default: L5</span><br><span class="line">   L2</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;AA&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L5</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE 3</span><br><span class="line">    GOTO L5</span><br><span class="line">   L3</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;BB&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L5</span><br><span class="line">    ICONST_1</span><br><span class="line">    ISTORE 3</span><br><span class="line">    GOTO L5</span><br><span class="line">   L4</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;Test3&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L5</span><br><span class="line">    ICONST_2</span><br><span class="line">    ISTORE 3</span><br><span class="line">   L5</span><br><span class="line">    ILOAD 3</span><br><span class="line">    TABLESWITCH</span><br><span class="line">      0: L6</span><br><span class="line">      1: L7</span><br><span class="line">      2: L8</span><br><span class="line">      default: L9</span><br><span class="line">   L6</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test1&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L10</span><br><span class="line">    GOTO L9</span><br><span class="line">   L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test2&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L11</span><br><span class="line">    GOTO L9</span><br><span class="line">   L8</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test3&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L9</span><br><span class="line">    RETURN</span><br></pre></td></tr></table></figure>
<p>String的逻辑并不只是简单的替换为int的switch，接下来讲一下这里的逻辑</p>
<ol>
<li>获取目标String的hashCode作为switch的目标值，取所有case对应String的hashCode作为case序列，可以理解为如下伪代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void stringSwitch() &#123;</span><br><span class="line">    String a = &quot;&quot;;</span><br><span class="line">    switch (a.hashCode()) &#123;</span><br><span class="line">        case &quot;AA&quot;.hashCode():</span><br><span class="line">            System.out.println(&quot;Test1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;BB&quot;.hashCode():</span><br><span class="line">            System.out.println(&quot;Test2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Test3&quot;.hashCode:</span><br><span class="line">            System.out.println(&quot;Test3&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用以上生成的目标值与case序列生成<code>tableswitch</code>或者<code>lookupswitch</code>指令</li>
<li>case对应的执行逻辑中通过<code>String#equals</code>判断目标String与当前case分支对应的String是否相等，如果相等则会在本地变量表中存储一个下标，下标值为当前分支在<code>switch</code>中位置，默认该下标为-1。</li>
<li>执行一个<code>tableswitch</code>，获取到之前在本地变量表中存储的下标作为目标值，case序列则为[0，n-1]，其中n为switch的分支数量，这个<code>tableswitch</code>的作用是跳转到真正的执行逻辑。</li>
</ol>
<h2 id="目标值的hashCode冲突"><a href="#目标值的hashCode冲突" class="headerlink" title="目标值的hashCode冲突"></a>目标值的hashCode冲突</h2><p>由于String的hashCode是存在重复的，所以可能存在某个字符串与匹配的case对应字符串并不相同，但是hashCode相同导致成功匹配，这样会造成执行预期之外的逻辑。所以在第一个switch里hashCode匹配之后还需要对字符串进行比较，如此完成匹配后才会通过后续的一个<code>tableswtch</code>执行真正逻辑。</p>
<h2 id="case的hashCode冲突"><a href="#case的hashCode冲突" class="headerlink" title="case的hashCode冲突"></a>case的hashCode冲突</h2><p>case本身也存在hashCode的冲突，如”Aa”与”BB”的hashCode都是2112，生成的字节码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    private void stringSwitch() &#123;</span><br><span class="line">        String a = &quot;&quot;;</span><br><span class="line">        switch (a) &#123;</span><br><span class="line">            case &quot;Aa&quot;:</span><br><span class="line">                System.out.println(&quot;Test1&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;BB&quot;:</span><br><span class="line">                System.out.println(&quot;Test2&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;Test3&quot;:</span><br><span class="line">                System.out.println(&quot;Test3&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// access flags 0x2</span><br><span class="line">  private stringSwitch()V</span><br><span class="line">   L0</span><br><span class="line">    LDC &quot;&quot;</span><br><span class="line">    ASTORE 1</span><br><span class="line">   L1</span><br><span class="line">    ALOAD 1</span><br><span class="line">    ASTORE 2</span><br><span class="line">    ICONST_M1</span><br><span class="line">    ISTORE 3</span><br><span class="line">    ALOAD 2</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.hashCode ()I</span><br><span class="line">    LOOKUPSWITCH</span><br><span class="line">      2112: L2</span><br><span class="line">      80698817: L3</span><br><span class="line">      default: L4</span><br><span class="line">   L2</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;BB&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L5</span><br><span class="line">    ICONST_1</span><br><span class="line">    ISTORE 3</span><br><span class="line">    GOTO L4</span><br><span class="line">   L5</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;Aa&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L4</span><br><span class="line">    ICONST_0</span><br><span class="line">    ISTORE 3</span><br><span class="line">    GOTO L4</span><br><span class="line">   L3</span><br><span class="line">    ALOAD 2</span><br><span class="line">    LDC &quot;Test3&quot;</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.equals (Ljava/lang/Object;)Z</span><br><span class="line">    IFEQ L4</span><br><span class="line">    ICONST_2</span><br><span class="line">    ISTORE 3</span><br><span class="line">   L4</span><br><span class="line">    ILOAD 3</span><br><span class="line">    TABLESWITCH</span><br><span class="line">      0: L6</span><br><span class="line">      1: L7</span><br><span class="line">      2: L8</span><br><span class="line">      default: L9</span><br><span class="line">   L6</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test1&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L10</span><br><span class="line">    GOTO L9</span><br><span class="line">   L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test2&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L11</span><br><span class="line">    GOTO L9</span><br><span class="line">   L8</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;Test3&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L9</span><br><span class="line">    RETURN</span><br></pre></td></tr></table></figure>
<p>可以看出生成的<code>lookupswitch</code>只包含两个case，”Aa”与”BB”执行同一个逻辑，而在逻辑内部会将目标字符串分别与”Aa”、”BB”进行比较以计算后续<code>tableswitch</code>中的目标值，其他逻辑不变。</p>
<h1 id="枚举的Switch"><a href="#枚举的Switch" class="headerlink" title="枚举的Switch"></a>枚举的Switch</h1><p>枚举并不是单纯的使用<code>ordinal()</code>获取int然后生成<code>switch</code>，因为这样并不能保证生成<code>tableswitch</code>，所以做了一些额外操作保证生成<code>tableswitch</code>。<br>编译器会生成一个int[]数据，长度为枚举的长度，然后将<code>switch</code>中的case按顺序取ordinal()值作为下标加到数组中，value为在<code>switch</code>中的顺序。通过目标枚举的<code>ordinal()</code>从数组中获取index，该index则为后续<code>tableswitch</code>的目标值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private enum E &#123;</span><br><span class="line">    a, b, c</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">  private void enumSwitch() &#123;</span><br><span class="line">        E a = E.a;</span><br><span class="line">        switch (a) &#123;</span><br><span class="line">            case a:</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case c:</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static final /* synthetic */ int[] $SwitchMap$M$E = new int[E.values().length];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            $SwitchMap$M$E[E.a.ordinal()] = 1;</span><br><span class="line">        &#125; catch (NoSuchFieldError e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            $SwitchMap$M$E[E.c.ordinal()] = 2;</span><br><span class="line">        &#125; catch (NoSuchFieldError e3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // access flags 0x2</span><br><span class="line">  private enumSwitch()V</span><br><span class="line">   L0</span><br><span class="line">    GETSTATIC M$E.a : LM$E;</span><br><span class="line">    ASTORE 1</span><br><span class="line">   L1</span><br><span class="line">    GETSTATIC M$1.$SwitchMap$M$E : [I</span><br><span class="line">    ALOAD 1</span><br><span class="line">    INVOKEVIRTUAL M$E.ordinal ()I</span><br><span class="line">    IALOAD</span><br><span class="line">    LOOKUPSWITCH</span><br><span class="line">      1: L2</span><br><span class="line">      2: L3</span><br><span class="line">      default: L4</span><br></pre></td></tr></table></figure>
<h1 id="Dex对Switch的优化"><a href="#Dex对Switch的优化" class="headerlink" title="Dex对Switch的优化"></a>Dex对Switch的优化</h1><p>开发过程中解包看生成的字节码是否正确的时候，发现生成的switch语句和预期的不太一样，但是逻辑上是一致的，而且看起来更加高效，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始代码</span><br><span class="line">public void test() &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            System.out.println(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            System.out.println(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 100:</span><br><span class="line">            System.out.println(&quot;100&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// apk反编译代码</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        if (0 != 100) &#123;</span><br><span class="line">            switch (0) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    System.out.println(&quot;1&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                case 2:</span><br><span class="line">                    System.out.println(&quot;2&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                case 3:</span><br><span class="line">                    System.out.println(&quot;3&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                default:</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;100&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出四个case中连续的三个独自组成了一个switch，而另一个case使用if语句来进行判断，这样的好处就是原本的<code>lookupswitch</code>变成了<code>tableswitch</code>。最开始怀疑是proguard做的优化，后来发现debug下也是如此，就开始找生成dex的相关代码，最后发现相关逻辑在<a href="https://r8.googlesource.com/r8/+/refs/heads/d8-1.0/src/main/java/com/android/tools/r8/ir/optimize/CodeRewriter.java">CodeRewriter</a>中，其中的rewriteSwitch方法负责优化switch逻辑，大概逻辑如下</p>
<ol>
<li>如果<code>switch</code>中只有一个分支，则转换为if语句</li>
<li>如果存在多个分支，通过遍历排序后的case序列，生成两个变量<code>sequences</code>和<code>outliers</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;IntList&gt; sequences = new ArrayList();</span><br><span class="line">IntList outliers = new IntArrayList();</span><br></pre></td></tr></table></figure>
<p><code>sequences</code>为case中连续序列的合集，<code>outliers</code>则是零散case的合集，举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (a) &#123;</span><br><span class="line">    case 1: break;</span><br><span class="line">    case 20: break;</span><br><span class="line">    case 21: break;</span><br><span class="line">    case 50: break;</span><br><span class="line">    case 101: break;</span><br><span class="line">    case 102: break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<code>switch</code>语句将生成如下的sequences和outliers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequences = [&#123;20, 21&#125;, &#123;101, 102&#125;]</span><br><span class="line">outliers = &#123;1, 50&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>收集到连续序列与零散点后，可能存在以下两种优化</li>
<li>为sequences中每一个sequence创建tableSwitch，为outliers中每一个case创建if语句</li>
<li>为sequences中每一个sequence创建tableSwitch，为outliers所有点创建一个lookupswitch<br>是否采取优化与具体采用那种优化方式主要依赖于优化后预计生成指令的个数和大小，具体的策略可以参考具体的代码逻辑。</li>
</ol>
<h1 id="生成Switch"><a href="#生成Switch" class="headerlink" title="生成Switch"></a>生成Switch</h1><p>了解以上内容后生成switch语句问题就不大了，但是自己写太麻烦，一番搜索后发现AGP提供了一个<a href="https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/incremental/StringSwitch.java">StringSwitch.java</a>类可以让我们快捷的生成String的switch逻辑，不过它只处理了case的冲突情况并没有处理目标值的冲突，需要我们自己处理。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-3.html#jvms-3.10">jvm</a></li>
</ul>
]]></content>
      <categories>
        <category>字节码</category>
      </categories>
  </entry>
  <entry>
    <title>左右最值最大差</title>
    <url>/2016/09/19/%E5%B7%A6%E5%8F%B3%E6%9C%80%E5%80%BC%E6%9C%80%E5%A4%A7%E5%B7%AE/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个长度为N(N&gt;1)的整型数组A，可以将A划分成左右两个部分，左部分A[0..K]，右部分A[K+1..N-1]，K可以取值的范围是[0,N-2]。求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？<br>给定整数数组A和数组的大小n，请返回题目所求的答案。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先可以确定的就是两个数中肯定有一个是A中的最大值。<br>假设是A[i]，这时候我们有两种选择：左边和右边。由于使用k划分为左右两块，那么我们就要确定A[i]在左边还是右边。假设在左边，那我们要取的值肯定是右边的，可以确定的是无论k为多少，最右边的也就是A[n - 1]肯定在范围内，这时候我们判断一下，如果取得不是A[n - 1]，是A[i] ( k &lt; i &lt; n - 1)。如果大于A[n - 1]那我们还不如取A[n - 1]都会比这个差值大（只要调整k让i &lt; k就可以），如果A[i] &lt; A[n - 1]，那不用说我们肯定取A[n - 1],所以无论如何都是最右边的值。另一种情况一样，取最左边的值，所以我们取两端比较小的值就可以。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findMax(int[] A, int n) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i = 0; i != n; i++) &#123;</span><br><span class="line">        max = Math.max(max, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int min = Math.min(A[0], A[n - 1]);</span><br><span class="line">    return max - min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>年终奖问题</title>
    <url>/2016/09/20/%E5%B9%B4%E7%BB%88%E5%A5%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6<em>6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。<br>给定一个6</em>6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以确定是动态规划，假设dp[i][j]表示从[0,0]到[i,j]的最大值，有以下四种情况</p>
<ol>
<li>i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0的时候，dp[i][j] &#x3D; board[0][0]</li>
<li>i &#x3D;&#x3D; 0 &amp;&amp; j !&#x3D; 0的时候，路径肯定是[i][j-1]到[i,j]的，dp[i][j] &#x3D; board[i][j] + dp[i][j-1]</li>
<li>i !&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0的时候，和第二种情况类似，dp[i][j] &#x3D; board[i][j] + dp[i-1][j]</li>
<li>i !&#x3D; 0 &amp;&amp; j !&#x3D; 0的时候，dp[i][j] &#x3D; max{dp[i][j-1], dp[i-1][j]} + board[i][j]</li>
</ol>
<p>最后输出dp[5][5]就可以了</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMost</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">	<span class="type">int</span> max[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != <span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != <span class="number">6</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">				max[i][j] = board[i][j];</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				max[i][j] = board[i][j] + max[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">				max[i][j] = board[i][j] + max[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				max[i][j] = Math.max(max[i - <span class="number">1</span>][j], max[i][j - <span class="number">1</span>]) + board[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>快速求二进制中1个数</title>
    <url>/2016/09/19/%E5%BF%AB%E9%80%9F%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>先放代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">countNum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">		n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>n &amp; (n - 1)能够置位最右边的1为0，这样循环计数，一直到为0就可以知道有多少个1了。<br>那为什么n &amp; (n - 1)能够置位最右边的1为0呢？右边的部分情况肯定是这样的：<br>…..1000..0<br>减去一后就是这样<br>…..0111..1<br>左边省略号部分是不会变的，这样进行&amp;运算后这一部分都变成0了<br>…..0000..0<br>这样最右边的1就置位了。<br>这段代码对于负数也可以用，比如输入－1，输出32。因为负数的二进制表现和正数不一样，负数首位肯定是1，以－1为例，int是32位，首先求1的反码1111…1110，加1就是补码1111..1111所以就是32个1。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>最大差值问题</title>
    <url>/2016/09/19/%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个长度为n的数组A，求满足0 &lt;&#x3D; a &lt;&#x3D; b &lt; n的A[b]-A[a]的最大值</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用到动态规划，假设f[i]表示前i个数组的最大值结果。f[i] 和 f[i - 1]比较就是要不要第i个数字。如果要，那么结果就是A[i] - (前i－1个数字中最小的)；如果不要，那就试f[i] - f[i - 1];这样状态方程就出来了。我们从最小情况i＝0出发，向上递增的同时更新前i－1中的最小值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="type">int</span> min = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != n; i++) &#123;</span><br><span class="line">		min = Math.<span class="built_in">min</span>(min, a[i]);</span><br><span class="line">		f[i] = Math.<span class="built_in">max</span>(f[i <span class="number">-1</span>], a[i] - min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>构建回文串检测</title>
    <url>/2019/10/09/%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串s，对s的子串进行检测。<br>每次检测，待检子串都可以表示为 queries[i] &#x3D; [left, right, k]。我们可以重新排列子串 s[left], …, s[right]，并从中选择最多k项替换成任何小写英文字母。 <br>如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。<br>返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。<br>注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] &#x3D; “aaa” 且 k &#x3D; 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; s.length, queries.length &lt;&#x3D; 10^5</li>
<li>0 &lt;&#x3D; queries[i][0] &lt;&#x3D; queries[i][1] &lt; s.length</li>
<li>0 &lt;&#x3D; queries[i][2] &lt;&#x3D; s.length</li>
<li>s 中只有小写英文字母</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/can-make-palindrome-from-substring">https://leetcode-cn.com/problems/can-make-palindrome-from-substring</a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以做两个操作，即重新排列和替换最多k项为任意小写字母。既然可以重新排列，那么我们肯定想的是把重复的字母给他按照中心对称排列，剩下的就是出现单数的字母了，比如出现了3次b，那么我们可以取2个b对称排列，剩下一个b，到最后就会变成一个回文字符串和其余的个数为1的字母了，我们只要把这些单个的字母转换成回文就好。我们可以进行k次转换，假设单个字母的个数为n，由于这些字母互不相同，所以只要k &gt;&#x3D; n &#x2F; 2就可以保证能够转换为回文，反之不行。<br>但是如果对每一个query都进行如上操作，会出现超时，所以我们对字符串s进行预处理，计算出0-i的子串包含字母c的次数，使用动态规划。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">canMakePaliQueries</span><span class="params">(String s, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">    	<span class="comment">// dp[i][j]表示字符串s的子串[0,i]包含小写字母(j + &#x27;a&#x27;)的个数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + ((s.charAt(i) - <span class="string">&#x27;a&#x27;</span>) == j? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">if</span> (queries == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] query : queries) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0</span>, query[<span class="number">0</span>]), s.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0</span>, query[<span class="number">1</span>]), s.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> query[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= (end - start + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            	<span class="comment">// 如果k大于等于子串长度的一半，直接判断为true</span></span><br><span class="line">                result.add(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 所有奇数字符的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    c = dp[end][i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// start-end的字符个数为dp[end] - dp[start - 1]</span></span><br><span class="line">                    c = dp[end][i] - dp[start - <span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(k &gt;= count / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>求二叉树满足条件路径</title>
    <url>/2017/08/25/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定二叉树，求的某一路径满足所有节点和为某一个值</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>采用递归，定义一个方法List<Node> getPath(Node root, int target),从root开始，首先判断root.val是否大于target，如果大于说明这个路径不可能成功，返回一个空的List就可以，如果小，那么target -&#x3D; val，然后递归左右节点，如果返回的List不空，那么说明满足，就可以add自己进path了。其实递归的实质，就是从叶子结点开始向上计算，所以返回的List应该是从叶子节点创建的，我们在程序中需要特殊判断叶子结点。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> int val = 0;</span></span><br><span class="line"><span class="comment"> TreeNode left = null;</span></span><br><span class="line"><span class="comment"> TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 非法节点,返回空list</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不满足，返回空list</span></span><br><span class="line">            <span class="keyword">if</span> (root.val != target) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 满足就add，返回</span></span><br><span class="line">            data.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普通节点</span></span><br><span class="line">        target -= root.val;</span><br><span class="line">        ArrayList&lt;Integer&gt; l = FindPath(root.left, target);</span><br><span class="line">        <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回非空，满足</span></span><br><span class="line">            l.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; r = FindPath(root.right, target);</span><br><span class="line">        <span class="keyword">if</span> (r.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回非空，满足</span></span><br><span class="line">            r.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右节点均不满足,返回空list</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>前面我们只需要找到一条就可以了，但是如果要求我们找到所有呢？思路其实一样，只不过变成List&lt;List<Node>&gt;而已，而且每次从左右节点获得的结果如果size !&#x3D; 0，那么就要把里面每一条path都add自己，然后把这两个结果合并返回，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">FindPath</span><span class="params">(TreeNode root,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 非法节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val != target) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            d.add(root.val);</span><br><span class="line">            data.add(d);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普通节点</span></span><br><span class="line">        target -= root.val;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; l = FindPath(root.left, target);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; r = FindPath(root.right, target);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (l.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;Integer&gt; a : l) &#123;</span><br><span class="line">                a.add(<span class="number">0</span>, root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            data.addAll(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;Integer&gt; a : r) &#123;</span><br><span class="line">                a.add(<span class="number">0</span>, root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            data.addAll(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>消失的数字</title>
    <url>/2017/04/04/%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组a[]，长度为n，保证1&lt;&#x3D;a[i]&lt;&#x3D;n,找出1-n中所有未出现的数字，不使用额外空间且时间复杂度为O(n).</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>如果可以使用额外空间，我们会使用一块额外空间来记录某一个数字是否出现过，遍历一遍a来更新额外空间状态，然后遍历额外空间来获得未出现的数字。现在不允许使用额外空间，我们可以不可以直接在数组上来保存状态？可以这样做，假设数组长度为n，我们发现a[0]&#x3D;3，那么说明3出现一次，由于数组下标是0~n-1，所以我们更新下标为2的值来表示3出现一次，怎么更新呢？直接让a[2]+n这样的话每次使用数组都要%n得到实际的值，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 完成此次循环后，nums[i]代表i+1出现的次数</span></span><br><span class="line">        <span class="comment">// 通过和将值和n比较，如果大于n说明有出现过i+1的值</span></span><br><span class="line">        <span class="comment">// 每次发现一个值，就－1然后和%n防止已经出现多次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums[(nums[i] - <span class="number">1</span>) % n] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                result.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>自定义动画实现splash页面3d旋转切换主页面</title>
    <url>/2016/07/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0splash%E9%A1%B5%E9%9D%A23d%E6%97%8B%E8%BD%AC%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h1><p>在Animation类中重写方法applyTransformation方法，该方法有两个参数</p>
<ul>
<li>float interpolatedTime：取值范围为0－1，具体我也不清楚，和时间有关的参数，应该是表示时间过去了多久。</li>
<li>Transformation t：从该参数中可以的到Matrix，通过修改这个Matrix配合interpolatedTime实现动画</li>
</ul>
<p>接下来实现一个以自身中心缩小到0的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnimation</span> <span class="keyword">extends</span> <span class="title class_">Animation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mWidthCenter, mHeightCenter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写初始化方法，可以得到当前目标的长宽</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> parentWidth, <span class="type">int</span> parentHeight)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">        <span class="built_in">this</span>.mWidthCenter = width / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">this</span>.mHeightCenter = height / <span class="number">2</span>;</span><br><span class="line">        setFillAfter(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyTransformation</span><span class="params">(<span class="type">float</span> interpolatedTime, Transformation t)</span> &#123;</span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> t.getMatrix();</span><br><span class="line">        <span class="comment">//1－interpolatedTime从1到0完成动画</span></span><br><span class="line">        matrix.setScale(</span><br><span class="line">                <span class="number">1</span> - interpolatedTime, <span class="number">1</span> - interpolatedTime, </span><br><span class="line">                mWidthCenter, mHeightCenter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyAnimation</span> <span class="variable">animation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAnimation</span>();</span><br><span class="line">animation.setDuration(<span class="number">3000</span>);</span><br><span class="line">icLauncher.startAnimation(animation);</span><br></pre></td></tr></table></figure>

<p>也可以通过Camera的使用达到3D的效果，接下来修改一下上述代码实现一个图片围绕Y轴旋转的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Camera</span></span><br><span class="line">   <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> parentWidth, <span class="type">int</span> parentHeight)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">       <span class="built_in">this</span>.mWidthCenter = width / <span class="number">2</span>;</span><br><span class="line">       <span class="built_in">this</span>.mHeightCenter = height / <span class="number">2</span>;</span><br><span class="line">       setFillAfter(<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyTransformation</span><span class="params">(<span class="type">float</span> interpolatedTime, Transformation t)</span> &#123;</span><br><span class="line">       <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> t.getMatrix();</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       matrix.setScale(</span></span><br><span class="line"><span class="comment">               1 - interpolatedTime, 1 - interpolatedTime,</span></span><br><span class="line"><span class="comment">               mWidthCenter, mHeightCenter);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       camera.save();</span><br><span class="line">       camera.rotateY(<span class="number">360</span> * interpolatedTime);</span><br><span class="line">       camera.getMatrix(matrix);</span><br><span class="line">       camera.restore();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//matrix.preTranslate(mWidthCenter, mHeightCenter);</span></span><br><span class="line">       <span class="comment">//matrix.postTranslate(-mWidthCenter, -mHeightCenter);</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码不复杂，刚开始创建一个Camera，然后在applyTransformation方法中对camera旋转，xy坐标就是普通的xy坐标，向右x正方向，向下y正方向，camera其实可以看作是在z轴上从上向下看的，也就是我们平时的视角，现在让camera绕y旋转，这里需要注意，我们通过360 ＊ interpolatedTime完成0到360度的旋转，但是每次都是从0开始旋转，所以在旋转之前需要save()保存camera最开始的位置（0的地方），完成旋转后将参数通过getMatrix(matrix)传递给matrix，然后restore()复原。</p>
<h1 id="splash切换效果"><a href="#splash切换效果" class="headerlink" title="splash切换效果"></a>splash切换效果</h1><p>实现这个效果的思路是在一个FrameLayout中包含两个RelativeLayout，一个是splash，一个是主页面，刚开始主页面是invisible的，然后旋转FrameLayout到90度，这是已经看不见了，然后把splash设为gone，主页设为visible，继续从270转到360。思路就是这样，但是我们需要一个3d旋转的类，我们就靠上面学习的自定义Animation，先贴代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现3d旋转的核心类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rotate3d</span> <span class="keyword">extends</span> <span class="title class_">Animation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> fromDegrees;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> toDegrees;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> centerX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> centerY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> reverse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rotate3d</span><span class="params">(<span class="type">float</span> fromDegrees, <span class="type">float</span> toDegrees, <span class="type">int</span> centerX, <span class="type">int</span> centerY, <span class="type">boolean</span> reverse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromDegrees = fromDegrees;</span><br><span class="line">        <span class="built_in">this</span>.toDegrees = toDegrees;</span><br><span class="line">        <span class="built_in">this</span>.centerX = centerX;</span><br><span class="line">        <span class="built_in">this</span>.centerY = centerY;</span><br><span class="line">        <span class="built_in">this</span>.reverse = reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> parentWidth, <span class="type">int</span> parentHeight)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">        mCamera = <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyTransformation</span><span class="params">(<span class="type">float</span> interpolatedTime, Transformation t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.applyTransformation(interpolatedTime, t);</span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> t.getMatrix();</span><br><span class="line"></span><br><span class="line">        mCamera.save();</span><br><span class="line">        <span class="keyword">if</span> (!reverse) &#123;</span><br><span class="line">            <span class="comment">// 距离越来越远</span></span><br><span class="line">            mCamera.translate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">550</span> * interpolatedTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 距离越来越近</span></span><br><span class="line">            mCamera.translate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">550</span> * (<span class="number">1</span> - interpolatedTime));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">float</span> <span class="variable">degrees</span> <span class="operator">=</span> fromDegrees + (toDegrees - fromDegrees) * interpolatedTime;</span><br><span class="line">        mCamera.rotateY(degrees);</span><br><span class="line">        mCamera.getMatrix(matrix);</span><br><span class="line">        mCamera.restore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整matrix作用的中心</span></span><br><span class="line">        matrix.preTranslate(-centerX, -centerY);</span><br><span class="line">        matrix.postTranslate(centerX, centerY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上面讲过，但有一些不同。我们通过设置camera的z轴距离实现远离和靠近的效果，当splash旋转的时候我们渐渐远离，这是reverse为false，主页出现时渐渐靠近，reverse为true。最后的matrix调整translate是调整matrix作用的中心，pre就是最开始调到中心，动画完成了就调回来。<br><img src="/images/3dmatrix.gif" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title>自己动手写一个简单的Android下拉刷新</title>
    <url>/2018/04/12/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Android%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一开始的时候尝试通过Android的事件分发机制来实现，但是child一旦消耗事件，那么后续事件是不会传给Parent的，只能重写dispatchTouchEvent来拦截，这样做相当于重写了Android的事件分发机制，我自认水平是不够的。随后阅读了Android官方刷新空间SwipeRefreshLayout，发现是使用的NestedScrolling机制，具体使用可以看鸿洋大神的这篇文章<a href="https://blog.csdn.net/lmj623565791/article/details/52204039">https://blog.csdn.net/lmj623565791/article/details/52204039</a> 所以本篇文章就使用NestedScrolling机制来实现针对RecyclerView的下拉刷新功能，别的控件暂不支持。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>控件本身继承自LinearLayout，有两个child，分别是Header和Content，通过设置Header的TopMargin来控制Header的滑动效果。</p>
<h2 id="实现NestedScrollingParent"><a href="#实现NestedScrollingParent" class="headerlink" title="实现NestedScrollingParent"></a>实现NestedScrollingParent</h2><p>维护两个变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mUnConsumedY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mHeaderShowHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>mHeaderShowHeight表示当前Header显示部分的高度，mUnConsumedY表示当前给RecyclerView消费掉的Y距离，通过这个变量来判断RecyclerView是否滑到顶端。</p>
<h3 id="实现onNestedPreScroll方法"><a href="#实现onNestedPreScroll方法" class="headerlink" title="实现onNestedPreScroll方法"></a>实现onNestedPreScroll方法</h3><p>通过这个方法实现在滑动之前判断应该消费多少Y距离，只有两种情况</p>
<ul>
<li>向上滑动且mHeaderShowHeight大于0，这时候消费掉dy，不给child消费，同时更新mHeaderShowHeight</li>
<li>向下滑动且mUnConsumedY为0，这时候消费dy。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(View target, <span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span>[] consumed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dy &gt; <span class="number">0</span> &amp;&amp; mHeaderShowHeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// header显示的时候上滑</span></span><br><span class="line">        <span class="keyword">if</span> (dy &lt;= mHeaderShowHeight) &#123;</span><br><span class="line">            mHeaderShowHeight -= dy;</span><br><span class="line">            consumed[<span class="number">1</span>] = dy;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            consumed[<span class="number">1</span>] = mHeaderShowHeight;</span><br><span class="line">            mHeaderShowHeight = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span> &amp;&amp; mUnConsumedY == <span class="number">0</span>) &#123;</span><br><span class="line">        consumed[<span class="number">1</span>] = dy;</span><br><span class="line">        mHeaderShowHeight -= dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况皆为更新mUnConsumedY，在onNestedScroll方法中更新</span></span><br><span class="line">    Log.d(<span class="string">&quot;Debug&quot;</span>, mHeaderShowHeight + <span class="string">&quot; &quot;</span> + mUnConsumedY);</span><br><span class="line">    processHeaderShowHeight();</span><br><span class="line">    updateProgress(mHeaderShowHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理mHeaderShowHeight，如果高于mHeaderHeight，加一个滑动的阻力</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processHeaderShowHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 计算阻力作用后的mHeaderShowHeight</span></span><br><span class="line">    <span class="keyword">if</span> (mHeaderShowHeight &gt; mHeaderHeight) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">extra</span> <span class="operator">=</span> mHeaderShowHeight - mHeaderHeight;</span><br><span class="line">        <span class="comment">// 阻力系数</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">dragRatio</span> <span class="operator">=</span> mHeaderHeight * <span class="number">1.0f</span> / mHeaderShowHeight;</span><br><span class="line">        mHeaderShowHeight = (<span class="type">int</span>) (mHeaderHeight + extra * dragRatio);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过mHeaderShowHeight来设置topMargin</span></span><br><span class="line">    setHeaderTopMarginWithShowHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据mHeaderShowHeight更新当前进度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mHeaderShowHeight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateProgress</span><span class="params">(<span class="type">int</span> mHeaderShowHeight)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mListener.onRefreshProgress(mHeaderShowHeight * <span class="number">1.0f</span> / mHeaderHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的情况都是RecyclerView滑动，在onNestedScroll中更新mUnConsumedY</p>
<h3 id="实现onNestedScroll方法"><a href="#实现onNestedScroll方法" class="headerlink" title="实现onNestedScroll方法"></a>实现onNestedScroll方法</h3><p>这个方法更新mUnConsumedY</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在子view滑动后通过消耗和未消耗的，来计算子view是否滑动到最顶端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dxConsumed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dyConsumed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dxUnconsumed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dyUnconsumed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedScroll</span><span class="params">(View target, <span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line">    mUnConsumedY += dyConsumed;</span><br><span class="line">    mUnConsumedY = Math.max(mUnConsumedY, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现onStopNestedScroll方法"><a href="#实现onStopNestedScroll方法" class="headerlink" title="实现onStopNestedScroll方法"></a>实现onStopNestedScroll方法</h3><p>这个方法里判断当前的状态，如果不是正在刷新或者释放刷新状态，都隐藏Header，否则进入刷新状态，判断是否释放刷新状态的阈值通过回调获得，回调下面来说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopNestedScroll</span><span class="params">(View child)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStopNestedScroll(child);</span><br><span class="line">    <span class="keyword">if</span> (mHeaderShowHeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">changeStateRatio</span> <span class="operator">=</span> mListener == <span class="literal">null</span>? <span class="number">1.0f</span> : mListener.getChangeStateRatio();</span><br><span class="line">        <span class="keyword">if</span> (mHeaderShowHeight * <span class="number">1.0f</span> / mHeaderHeight &gt; changeStateRatio) &#123;</span><br><span class="line">            <span class="comment">// 开始刷新</span></span><br><span class="line">            startRefreshing();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stopRefreshing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现onNestedPreFling"><a href="#实现onNestedPreFling" class="headerlink" title="实现onNestedPreFling"></a>实现onNestedPreFling</h3><p>由于Fling操作会导致mUnConsumedY不能正常更新，所以重写这个方法返回true来禁止child实现这个操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNestedPreFling</span><span class="params">(View target, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义刷新回调"><a href="#定义刷新回调" class="headerlink" title="定义刷新回调"></a>定义刷新回调</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EasyRefreshListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefreshing</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据progress改变内容</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefreshProgress</span><span class="params">(<span class="type">float</span> progress)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变下拉状态的阈值</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getChangeStateRatio</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是大致思路，具体的代码已经上传到<a href="https://github.com/1014277960/EasyRefresh">Github</a>，后续会完善各项功能</p>
]]></content>
      <categories>
        <category>Android自定义控件</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式--单例</title>
    <url>/2016/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当希望一个类在程序中只会有一个实例存在的时候，单例模式便会派上用场。为了限制该类对象被随意的创建，我们将构造方法声明为private，但是这样就无法创建对象了，我们该怎么办呢？接下来就从最简单的单例模式讲起。</p>
<h1 id="最简单的单例"><a href="#最简单的单例" class="headerlink" title="最简单的单例"></a>最简单的单例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//初始化操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在类内部创建一个静态的Singleton变量，通过静态方法返回，这样的代码是线程安全的，因为虚拟机加载这个类的时候会保证static的变量只由一个线程执行一次，在使用该变量之前保证创建完成。</p>
<h1 id="性能更进一步"><a href="#性能更进一步" class="headerlink" title="性能更进一步"></a>性能更进一步</h1><p>第一种方法由于在加载类的时候就会创建static变量，占用内存，这不是我们希望看到的，理想情况是当我们需要用到的时候再创建实例，也就是要延迟实例化，我们修改代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//初始化操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的话又会造成线程不安全的情况，当两个线程都执行if(instance &#x3D;&#x3D; null)后，假设线程1先进入下一步，得到一个实例，之后线程2就会进入下一步，同样获得一个新的实例，这就会造成存在多个实例，继续修改代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//初始化操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加锁后就可以实现多线程安全访问，但是又出现一个问题，就是在多线程的情况下对整个方法加锁就会造成性能不够好，我们可以缩小同步的范围来加强性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//初始化操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">	                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instance要用volatile修饰，这样就对synchronized有可见性。</p>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>我们需要的是线程安全且延迟实例化的单例，可以根据第一种代码修改，可以声明一个内部类，内部类里面持有一个Singleton实例，在getInstance方法里获得该内部类的实例，也只会在这个时候jvm去加载这个内部类，创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="comment">//初始化操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingleHolder</span> &#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> SingleHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h1><p>其实以上的方法有一个共同的缺陷，那就是如果将单例序列化存储到本地在读取回来，那么获得另一个一摸一样的instance，这样也就不是所谓的单例了，而单元素的枚举类型是实现Singleton的最佳方法。</p>
<h3 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h3><p>最基本的使用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">	A,</span><br><span class="line">	B,</span><br><span class="line">	C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器将它变成这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Type A;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Type B;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Type C;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是三个静态的Type对象A、B、C。<br>我们可以把Type看成一个类，它也有构造方法和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Type.staticPrint();</span><br><span class="line">		Type.A.print();</span><br><span class="line">		Type.B.print();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">		A,</span><br><span class="line">		B &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;B print()&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		C;</span><br><span class="line">		Type() &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticPrint</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;static print()&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;print()&quot;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>	init<br>	init<br>	init<br>	static print()<br>	print()<br>	B print()<br>可以知道，首先enum会实例化三个静态的Type对象，调用构造方法，构造方法是私有的。我们可以通过Type访问静态的类方法，通过ABC访问实例方法，当然具体的对象如B可以重写父类的实例方法，此外，我们也可以定义抽象方法，这样每个实例ABC都需要实现该方法。</p>
<h3 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Singleton mInstance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Type</span><span class="params">()</span> &#123;</span><br><span class="line">		mInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们确定了构造方法是私有的，然后我们访问枚举实例的时候会执行构造方法，同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。 也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>贝塞尔曲线</title>
    <url>/2019/08/08/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="贝塞尔原理"><a href="#贝塞尔原理" class="headerlink" title="贝塞尔原理"></a>贝塞尔原理</h1><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线，是应用于二维图形应用程序的数学曲线，贝塞尔曲线的运用十分广泛，可以说贝塞尔曲线奠定了计算机绘图的基础(因为它可以将任何复杂的图形用精确的数学语言进行描述)，接下来以二阶贝塞尔曲线为例介绍贝塞尔曲线的定义、性质。<br>二阶曲线由两个数据点(P0 和 P2)，一个控制点(P1)来描述曲线状态，如图所示红色曲线就是二阶贝塞尔曲线<br><img src="/images/bezier1.gif"><br>推导过程如下<br><img src="/images/bezier2.png"></p>
<ol>
<li>在P0P1、P1P2上分别取点A、B满足</li>
</ol>
<ul>
<li>P0A&#x2F;P0P1 &#x3D; P1B&#x2F;P1P2 &#x3D; t</li>
</ul>
<ol start="2">
<li>在AB上取点C满足</li>
</ol>
<ul>
<li>AC&#x2F;AB &#x3D; t<br>C为贝塞尔曲线上一个点，当t从0-1变化时，所有满足条件的点C构成完整的贝塞尔曲线，公式为<br><img src="/images/bezier3.png"><br>二阶贝塞尔曲线有两个特性:</li>
</ul>
<ol>
<li>以P0P2为底边，二阶贝塞尔曲线最高点的坐标为P1P3的中点，其中P3为P0P2的中点。</li>
<li>贝塞尔曲线与P0P1、P1P2分别相切于P0、P2点</li>
</ol>
<p>三阶贝塞尔曲线如下如所示，构造过程和二阶类似<br><img src="/images/bezier4.gif"><br><img src="/images/bezier5.png"></p>
<h1 id="应用一-实现粘性效果"><a href="#应用一-实现粘性效果" class="headerlink" title="应用一:实现粘性效果"></a>应用一:实现粘性效果</h1><p>使用贝塞尔曲线可以实现很多复杂的动画效果，这里介绍一种较为简单的小球粘性下拉动画，效果如下<br><img src="/images/bezier6.gif"><br>首先我们定义小球可以下拉的最大高度为MAX_HEIGHT，当小球随手势向下拉动的时候通过当前的高度&#x2F;MAX_HEIGHT计算出当前的进度progress，后面就通过progress来确定绘制所需要的所有点<br><img src="/images/bezier7.png"><br>如图所示在圆上取点e1，e1与圆心连城的直线与垂线夹角为θ。过e1做圆的切线交基准线L于c1点，取基准线上s1点和e1为数据点，c1为控制点做二阶贝塞尔曲线(右侧类似)即可实现粘性效果。其中随着progress从0到1变化过程中</p>
<ul>
<li>θ从0到105度变化</li>
<li>s1从最左侧到距离O点120距离移动<br>以下是添加辅助点后的效果<br><img src="/images/bezier8.gif"></li>
</ul>
<h1 id="应用二-平滑拟合曲线"><a href="#应用二-平滑拟合曲线" class="headerlink" title="应用二:平滑拟合曲线"></a>应用二:平滑拟合曲线</h1><p>在一些绘图应用上会提供用户手动绘制的功能，绘制的曲线其实是一个一个点连接而成的，这样就会导致曲线可能并不光滑，出现很多折角，这种情况就可以用贝塞尔曲线进行拟合，拟合方法如下：<br><img src="/images/bezier9.png"><br>假设绘制路径上有三个连续的点a、b、c，则分别取ab、bc中点A、B，以AB为数据点，b为控制点绘制二阶贝塞尔曲线。<br>使用如上方法就可以实现平滑曲线绘制，部分代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author：wulinpeng</span></span><br><span class="line"><span class="comment"> * date：2019/5/27 22:26</span></span><br><span class="line"><span class="comment"> * desc: 平滑绘制Path，将lineTo通过二阶贝塞尔转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmoothCurvePath</span>: Path() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">points</span> <span class="operator">=</span> mutableListOf&lt;PointF&gt;()</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">moveTo</span><span class="params">(x: Float, y: Float)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.moveTo(x, y)</span><br><span class="line">        points.add(PointF(x, y))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">lineTo</span><span class="params">(x: Float, y: Float)</span> &#123;</span><br><span class="line">        points.add(PointF(x, y))</span><br><span class="line">        makeBezier()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">makeBezier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">size</span> <span class="operator">=</span> points.size</span><br><span class="line">        <span class="type">val</span> <span class="variable">prePoint</span> <span class="operator">=</span> points[size - <span class="number">2</span>]</span><br><span class="line">        <span class="type">val</span> <span class="variable">curPoint</span> <span class="operator">=</span> points[size - <span class="number">1</span>]</span><br><span class="line">        quadTo(prePoint.x, prePoint.y, (prePoint.x + curPoint.x) / <span class="number">2</span>, (prePoint.y + curPoint.y) / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.reset()</span><br><span class="line">        points.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="/images/bezier10.png"></p>
<h1 id="应用三-小说仿真翻页效果"><a href="#应用三-小说仿真翻页效果" class="headerlink" title="应用三:小说仿真翻页效果"></a>应用三:小说仿真翻页效果</h1><p>目前市面上的小说阅读app基本都提供仿真翻页阅读的功能，本节将详细介绍实现的细节，demo效果如下<br><img src="/images/bezier11.gif"></p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>本节着重讲解实现翻页效果的理论知识，下面这张图是整个翻页效果的精髓所在，接下来以从右下角开始翻页为例进行讲解。<br><img src="/images/bezier12.png" alt="图1"><br><img src="/images/bezier13.png" alt="图2"><br><img src="/images/bezier14.png" alt="图3"></p>
<p>如图2所示，黄色区域为当前页面的背面，蓝色区域为下一页的内容，绿色为当前页面，我们第一步要做的就是确定三块区域对应的Path，这样后面才可以在Canvas上绘制对应的内容。<br>如图3所示，三角形aeh与三角形feh关于eh对称，aeh也就是我们翻页的部分，但是如果就按照这样来绘制显得不够逼真，没有真实翻页的效果，所以我们需要给翻页部分做一个平滑过渡的效果。经过ag中点做直线cj牌型与eh，交与三角形aeh于b、k点，且c、j为边界上的点。以cb为二阶贝塞尔曲线数据点，e为控制点做贝塞尔曲线，由贝塞尔性质可知该曲线与ce、ab相切，可以达到平滑过渡的效果。同理以ja为二阶贝塞尔曲线数据点，h为控制点做贝塞尔曲线平滑多度ih、ak。分别取两条贝塞尔曲线的定点d、i连接，则d、b、a、k、i5个点连接的区域为图2黄色区域，也就是当前页背页的区域。有了黄色区域的范围，就可以很简单的求得蓝色区域和绿色区域的范围了。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现整体的效果非常复杂，本节重点讲解几个比较关键的点，首先将图3中的点命名</p>
<ul>
<li>a -&gt; mTouch</li>
<li>f -&gt; mCorner</li>
<li>b&#x2F;c&#x2F;d&#x2F;e -&gt; mBzEnd1&#x2F;mBzStart1&#x2F;mBzVertex1&#x2F;mBzControl1</li>
<li>h&#x2F;i&#x2F;j&#x2F;k -&gt; mBzControl2&#x2F;mBzVertex2&#x2F;mBzStart2&#x2F;mBzEnd2<br>1.mTouch点的确定<br>由于在实际触摸中会出现控制点超出屏幕的情况，所以这时候不能将触摸点当作mTouch的坐标，而是应该进行转换。转换原理是将超出屏幕的控制点缩小到屏幕的临界点(刚好不超出屏幕)，计算该缩放的比例，将触摸点按该比例向mCorner点缩小。<br>2.获得黄色区域Path<br>由于d-&gt;b &#x2F; i-&gt;k的曲线为贝塞尔曲线的一部分，我们无法直接通过Path来构造，只能通别的方式来获得到。第一步我们先获取黄色和蓝色区域的并集Path1，这一块没有什么难度，其中quadTo是连接二阶贝塞尔曲线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">path1</span> <span class="operator">=</span> Path().apply &#123;</span><br><span class="line">    moveTo(mBzStart1.x, mBzStart1.y)</span><br><span class="line">    quadTo(mBzControl1.x, mBzControl1.y, mBzEnd1.x, mBzEnd1.y)</span><br><span class="line">    lineTo(mTouch.x, mTouch.y)</span><br><span class="line">    lineTo(mBzEnd2.x, mBzEnd2.y)</span><br><span class="line">    quadTo(mBzControl2.x, mBzControl2.y, mBzStart2.x, mBzStart2.y)</span><br><span class="line">    lineTo(mCornerX, mCornerY)</span><br><span class="line">    close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步将dbaki通过线段连接得到Path2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">path2</span> <span class="operator">=</span> Path().apply &#123;</span><br><span class="line">    moveTo(mBzVertex1.x, mBzVertex1.y)</span><br><span class="line">    lineTo(mBzVertex2.x, mBzVertex2.y)</span><br><span class="line">    lineTo(mBzEnd2.x, mBzEnd2.y)</span><br><span class="line">    lineTo(mTouch.x, mTouch.y)</span><br><span class="line">    lineTo(mBzEnd1.x, mBzEnd1.y)</span><br><span class="line">    close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Path2使用的是线段相连，所以比我们想要获得的黄色区域要多出一部分，而恰好Path2只有这部分不在Path1中，所以我们可以通过取Path1和Path2的并集求得黄色区域的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">matrix</span> <span class="operator">=</span> getSymmetricalMatrix(mCalcData.mBzControl1, mCalcData.mBzControl2)</span><br><span class="line">canvas.save()</span><br><span class="line">canvas.clipPath(mPath1)</span><br><span class="line">canvas.clipPath(mPath2, Region.Op.INTERSECT)</span><br><span class="line"><span class="comment">// 当前页面对称变换后的矩形会和背页区域有一定的空隙，故背页不绘制正常bg，只绘制文字，在此之前填充背景色</span></span><br><span class="line">canvas.drawColor(mBackPageColor)</span><br><span class="line">canvas.drawBitmap(curBitmapWithNormalBg, matrix, <span class="literal">null</span>)</span><br><span class="line">canvas.restore()</span><br></pre></td></tr></table></figure>
<p>这里在绘制背页的时候需要注意两个点</p>
<ol>
<li>绘制文字的时候需要做关于eh的对称变化，这样才有背页的效果，我们需要做的是构造一个矩阵来实现，若点A1(X1,Y1)关于直线y&#x3D;kx+b成轴对称，则对应点A2（X2，Y2）的坐标为<br><img src="/images/bezier15.png"><br><img src="/images/bezier16.png"></li>
</ol>
<p>那么就可以求出对应的矩阵</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于两个control连线的对称矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">getSymmetricalMatrix</span><span class="params">(point1: PointF, point2: PointF)</span>: Matrix &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">k</span> <span class="operator">=</span> (point1.y - point2.y) / (point1.x - point2.x)</span><br><span class="line">    <span class="type">val</span> <span class="variable">values</span> <span class="operator">=</span> FloatArray(<span class="number">9</span>)</span><br><span class="line">    values[<span class="number">0</span>] = -<span class="number">1</span> * (k * k - <span class="number">1</span>) / (k * k + <span class="number">1</span>)</span><br><span class="line">    values[<span class="number">1</span>] = <span class="number">2</span> * k / (k * k + <span class="number">1</span>)</span><br><span class="line">    values[<span class="number">3</span>] = values[<span class="number">1</span>]</span><br><span class="line">    values[<span class="number">4</span>] = -values[<span class="number">0</span>]</span><br><span class="line">    values[<span class="number">8</span>] = <span class="number">1f</span></span><br><span class="line"></span><br><span class="line">    <span class="type">val</span> <span class="variable">b</span> <span class="operator">=</span> point1.y - point1.x * k</span><br><span class="line">    values[<span class="number">2</span>] = -<span class="number">2</span> * k * b / (k * k + <span class="number">1</span>)</span><br><span class="line">    values[<span class="number">5</span>] = <span class="number">2</span> * b / (k * k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">val</span> <span class="variable">matrix</span> <span class="operator">=</span> Matrix()</span><br><span class="line">    matrix.setValues(values)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>由于背页使用了贝塞尔曲线进行平滑扩展，所以绘制的区域是比实际区域要大，在绘制背页的时候不能带背景图片，只能用纯色填充，不然会出现空白区域</li>
</ol>
]]></content>
      <categories>
        <category>贝塞尔</category>
      </categories>
  </entry>
</search>
